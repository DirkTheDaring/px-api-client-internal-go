/*
ProxMox VE API

ProxMox VE API

API version: 8.3
Contact: baldur@email.de
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pxapiobject

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


type NodesApi interface {

	/*
	CreateContainer createContainer

	Create or restore a container.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@return ApiCreateContainerRequest
	*/
	CreateContainer(ctx context.Context, node string) ApiCreateContainerRequest

	// CreateContainerExecute executes the request
	//  @return CreateVM200Response
	CreateContainerExecute(r ApiCreateContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	CreateContainerSnapshot createContainerSnapshot

	Snapshot a container.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiCreateContainerSnapshotRequest
	*/
	CreateContainerSnapshot(ctx context.Context, node string, vmid int64) ApiCreateContainerSnapshotRequest

	// CreateContainerSnapshotExecute executes the request
	//  @return TaskStartResponse
	CreateContainerSnapshotExecute(r ApiCreateContainerSnapshotRequest) (*TaskStartResponse, *http.Response, error)

	/*
	CreateNodesSingleStorageSingleContent createNodesSingleStorageSingleContent

	Allocate disk images.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param storage storage
	@return ApiCreateNodesSingleStorageSingleContentRequest
	*/
	CreateNodesSingleStorageSingleContent(ctx context.Context, node string, storage string) ApiCreateNodesSingleStorageSingleContentRequest

	// CreateNodesSingleStorageSingleContentExecute executes the request
	//  @return CreateNodesSingleStorageSingleContent200Response
	CreateNodesSingleStorageSingleContentExecute(r ApiCreateNodesSingleStorageSingleContentRequest) (*CreateNodesSingleStorageSingleContent200Response, *http.Response, error)

	/*
	CreateVM createVM

	Create or restore a virtual machine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@return ApiCreateVMRequest
	*/
	CreateVM(ctx context.Context, node string) ApiCreateVMRequest

	// CreateVMExecute executes the request
	//  @return CreateVM200Response
	CreateVMExecute(r ApiCreateVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	CreateVMSnapshot createVMSnapshot

	Snapshot a VM.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiCreateVMSnapshotRequest
	*/
	CreateVMSnapshot(ctx context.Context, node string, vmid int64) ApiCreateVMSnapshotRequest

	// CreateVMSnapshotExecute executes the request
	//  @return TaskStartResponse
	CreateVMSnapshotExecute(r ApiCreateVMSnapshotRequest) (*TaskStartResponse, *http.Response, error)

	/*
	DeleteContainer deleteContainer

	Destroy the container (also delete all uses files).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiDeleteContainerRequest
	*/
	DeleteContainer(ctx context.Context, node string, vmid int64) ApiDeleteContainerRequest

	// DeleteContainerExecute executes the request
	//  @return CreateVM200Response
	DeleteContainerExecute(r ApiDeleteContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	DeleteContainerSnapshot deleteContainerSnapshot

	Delete a LXC snapshot.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param snapname snapname
	@param vmid vmid
	@return ApiDeleteContainerSnapshotRequest
	*/
	DeleteContainerSnapshot(ctx context.Context, node string, snapname string, vmid int64) ApiDeleteContainerSnapshotRequest

	// DeleteContainerSnapshotExecute executes the request
	//  @return TaskStartResponse
	DeleteContainerSnapshotExecute(r ApiDeleteContainerSnapshotRequest) (*TaskStartResponse, *http.Response, error)

	/*
	DeleteVM deleteVM

	Destroy the VM and  all used/owned volumes. Removes any VM specific permissions and firewall rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiDeleteVMRequest
	*/
	DeleteVM(ctx context.Context, node string, vmid int64) ApiDeleteVMRequest

	// DeleteVMExecute executes the request
	//  @return CreateVM200Response
	DeleteVMExecute(r ApiDeleteVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	DeleteVMSnapshot deleteVMSnapshot

	Delete a VM snapshot.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param snapname snapname
	@param vmid vmid
	@return ApiDeleteVMSnapshotRequest
	*/
	DeleteVMSnapshot(ctx context.Context, node string, snapname string, vmid int64) ApiDeleteVMSnapshotRequest

	// DeleteVMSnapshotExecute executes the request
	//  @return TaskStartResponse
	DeleteVMSnapshotExecute(r ApiDeleteVMSnapshotRequest) (*TaskStartResponse, *http.Response, error)

	/*
	GetContainer getContainer

	Directory index

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiGetContainerRequest
	*/
	GetContainer(ctx context.Context, node string, vmid int64) ApiGetContainerRequest

	// GetContainerExecute executes the request
	//  @return GetVM200Response
	GetContainerExecute(r ApiGetContainerRequest) (*GetVM200Response, *http.Response, error)

	/*
	GetContainerConfig getContainerConfig

	Get container configuration.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiGetContainerConfigRequest
	*/
	GetContainerConfig(ctx context.Context, node string, vmid int64) ApiGetContainerConfigRequest

	// GetContainerConfigExecute executes the request
	//  @return GetContainerConfig200Response
	GetContainerConfigExecute(r ApiGetContainerConfigRequest) (*GetContainerConfig200Response, *http.Response, error)

	/*
	GetContainerConfigPending getContainerConfigPending

	Get container configuration, including pending changes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiGetContainerConfigPendingRequest
	*/
	GetContainerConfigPending(ctx context.Context, node string, vmid int64) ApiGetContainerConfigPendingRequest

	// GetContainerConfigPendingExecute executes the request
	//  @return GetContainerConfigPending200Response
	GetContainerConfigPendingExecute(r ApiGetContainerConfigPendingRequest) (*GetContainerConfigPending200Response, *http.Response, error)

	/*
	GetContainerSnapshot getContainerSnapshot

	

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param snapname snapname
	@param vmid vmid
	@return ApiGetContainerSnapshotRequest
	*/
	GetContainerSnapshot(ctx context.Context, node string, snapname string, vmid int64) ApiGetContainerSnapshotRequest

	// GetContainerSnapshotExecute executes the request
	//  @return GetVMSnapshot200Response
	GetContainerSnapshotExecute(r ApiGetContainerSnapshotRequest) (*GetVMSnapshot200Response, *http.Response, error)

	/*
	GetContainerSnapshotConfig getContainerSnapshotConfig

	Get snapshot configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param snapname snapname
	@param vmid vmid
	@return ApiGetContainerSnapshotConfigRequest
	*/
	GetContainerSnapshotConfig(ctx context.Context, node string, snapname string, vmid int64) ApiGetContainerSnapshotConfigRequest

	// GetContainerSnapshotConfigExecute executes the request
	//  @return GetVMSnapshotConfig200Response
	GetContainerSnapshotConfigExecute(r ApiGetContainerSnapshotConfigRequest) (*GetVMSnapshotConfig200Response, *http.Response, error)

	/*
	GetContainerSnapshots getContainerSnapshots

	List all snapshots.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiGetContainerSnapshotsRequest
	*/
	GetContainerSnapshots(ctx context.Context, node string, vmid int64) ApiGetContainerSnapshotsRequest

	// GetContainerSnapshotsExecute executes the request
	//  @return GetContainerSnapshots200Response
	GetContainerSnapshotsExecute(r ApiGetContainerSnapshotsRequest) (*GetContainerSnapshots200Response, *http.Response, error)

	/*
	GetContainerStatus getContainerStatus

	Directory index

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiGetContainerStatusRequest
	*/
	GetContainerStatus(ctx context.Context, node string, vmid int64) ApiGetContainerStatusRequest

	// GetContainerStatusExecute executes the request
	//  @return GetVM200Response
	GetContainerStatusExecute(r ApiGetContainerStatusRequest) (*GetVM200Response, *http.Response, error)

	/*
	GetContainers getContainers

	LXC container index (per node).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@return ApiGetContainersRequest
	*/
	GetContainers(ctx context.Context, node string) ApiGetContainersRequest

	// GetContainersExecute executes the request
	//  @return GetContainers200Response
	GetContainersExecute(r ApiGetContainersRequest) (*GetContainers200Response, *http.Response, error)

	/*
	GetCurrentContainerStatus getCurrentContainerStatus

	Get virtual machine status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiGetCurrentContainerStatusRequest
	*/
	GetCurrentContainerStatus(ctx context.Context, node string, vmid int64) ApiGetCurrentContainerStatusRequest

	// GetCurrentContainerStatusExecute executes the request
	//  @return GetCurrentContainerStatus200Response
	GetCurrentContainerStatusExecute(r ApiGetCurrentContainerStatusRequest) (*GetCurrentContainerStatus200Response, *http.Response, error)

	/*
	GetCurrentVMStatus getCurrentVMStatus

	Get virtual machine status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiGetCurrentVMStatusRequest
	*/
	GetCurrentVMStatus(ctx context.Context, node string, vmid int64) ApiGetCurrentVMStatusRequest

	// GetCurrentVMStatusExecute executes the request
	//  @return GetCurrentVMStatus200Response
	GetCurrentVMStatusExecute(r ApiGetCurrentVMStatusRequest) (*GetCurrentVMStatus200Response, *http.Response, error)

	/*
	GetNodeTask getNodeTask

	

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param upid upid
	@return ApiGetNodeTaskRequest
	*/
	GetNodeTask(ctx context.Context, node string, upid string) ApiGetNodeTaskRequest

	// GetNodeTaskExecute executes the request
	//  @return GetVMSnapshot200Response
	GetNodeTaskExecute(r ApiGetNodeTaskRequest) (*GetVMSnapshot200Response, *http.Response, error)

	/*
	GetNodeTaskLog getNodeTaskLog

	Read task log.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param upid upid
	@return ApiGetNodeTaskLogRequest
	*/
	GetNodeTaskLog(ctx context.Context, node string, upid string) ApiGetNodeTaskLogRequest

	// GetNodeTaskLogExecute executes the request
	//  @return GetNodeTaskLog200Response
	GetNodeTaskLogExecute(r ApiGetNodeTaskLogRequest) (*GetNodeTaskLog200Response, *http.Response, error)

	/*
	GetNodeTaskStatus getNodeTaskStatus

	Read task status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param upid upid
	@return ApiGetNodeTaskStatusRequest
	*/
	GetNodeTaskStatus(ctx context.Context, node string, upid string) ApiGetNodeTaskStatusRequest

	// GetNodeTaskStatusExecute executes the request
	//  @return GetNodeTaskStatus200Response
	GetNodeTaskStatusExecute(r ApiGetNodeTaskStatusRequest) (*GetNodeTaskStatus200Response, *http.Response, error)

	/*
	GetNodeTasks getNodeTasks

	Read task list for one node (finished tasks).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@return ApiGetNodeTasksRequest
	*/
	GetNodeTasks(ctx context.Context, node string) ApiGetNodeTasksRequest

	// GetNodeTasksExecute executes the request
	//  @return GetNodeTasks200Response
	GetNodeTasksExecute(r ApiGetNodeTasksRequest) (*GetNodeTasks200Response, *http.Response, error)

	/*
	GetStorageContent getStorageContent

	List storage content.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param storage storage
	@return ApiGetStorageContentRequest
	*/
	GetStorageContent(ctx context.Context, node string, storage string) ApiGetStorageContentRequest

	// GetStorageContentExecute executes the request
	//  @return GetStorageContent200Response
	GetStorageContentExecute(r ApiGetStorageContentRequest) (*GetStorageContent200Response, *http.Response, error)

	/*
	GetStorages getStorages

	Get status for all datastores.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@return ApiGetStoragesRequest
	*/
	GetStorages(ctx context.Context, node string) ApiGetStoragesRequest

	// GetStoragesExecute executes the request
	//  @return GetStorages200Response
	GetStoragesExecute(r ApiGetStoragesRequest) (*GetStorages200Response, *http.Response, error)

	/*
	GetVM getVM

	Directory index

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiGetVMRequest
	*/
	GetVM(ctx context.Context, node string, vmid int64) ApiGetVMRequest

	// GetVMExecute executes the request
	//  @return GetVM200Response
	GetVMExecute(r ApiGetVMRequest) (*GetVM200Response, *http.Response, error)

	/*
	GetVMConfig getVMConfig

	Get the virtual machine configuration with pending configuration changes applied. Set the 'current' parameter to get the current configuration instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiGetVMConfigRequest
	*/
	GetVMConfig(ctx context.Context, node string, vmid int64) ApiGetVMConfigRequest

	// GetVMConfigExecute executes the request
	//  @return GetVMConfig200Response
	GetVMConfigExecute(r ApiGetVMConfigRequest) (*GetVMConfig200Response, *http.Response, error)

	/*
	GetVMConfigPending getVMConfigPending

	Get the virtual machine configuration with both current and pending values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiGetVMConfigPendingRequest
	*/
	GetVMConfigPending(ctx context.Context, node string, vmid int64) ApiGetVMConfigPendingRequest

	// GetVMConfigPendingExecute executes the request
	//  @return GetVMConfigPending200Response
	GetVMConfigPendingExecute(r ApiGetVMConfigPendingRequest) (*GetVMConfigPending200Response, *http.Response, error)

	/*
	GetVMSnapshot getVMSnapshot

	

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param snapname snapname
	@param vmid vmid
	@return ApiGetVMSnapshotRequest
	*/
	GetVMSnapshot(ctx context.Context, node string, snapname string, vmid int64) ApiGetVMSnapshotRequest

	// GetVMSnapshotExecute executes the request
	//  @return GetVMSnapshot200Response
	GetVMSnapshotExecute(r ApiGetVMSnapshotRequest) (*GetVMSnapshot200Response, *http.Response, error)

	/*
	GetVMSnapshotConfig getVMSnapshotConfig

	Get snapshot configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param snapname snapname
	@param vmid vmid
	@return ApiGetVMSnapshotConfigRequest
	*/
	GetVMSnapshotConfig(ctx context.Context, node string, snapname string, vmid int64) ApiGetVMSnapshotConfigRequest

	// GetVMSnapshotConfigExecute executes the request
	//  @return GetVMSnapshotConfig200Response
	GetVMSnapshotConfigExecute(r ApiGetVMSnapshotConfigRequest) (*GetVMSnapshotConfig200Response, *http.Response, error)

	/*
	GetVMSnapshots getVMSnapshots

	List all snapshots.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiGetVMSnapshotsRequest
	*/
	GetVMSnapshots(ctx context.Context, node string, vmid int64) ApiGetVMSnapshotsRequest

	// GetVMSnapshotsExecute executes the request
	//  @return GetVMSnapshots200Response
	GetVMSnapshotsExecute(r ApiGetVMSnapshotsRequest) (*GetVMSnapshots200Response, *http.Response, error)

	/*
	GetVMs getVMs

	Virtual machine index (per node).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@return ApiGetVMsRequest
	*/
	GetVMs(ctx context.Context, node string) ApiGetVMsRequest

	// GetVMsExecute executes the request
	//  @return GetVMs200Response
	GetVMsExecute(r ApiGetVMsRequest) (*GetVMs200Response, *http.Response, error)

	/*
	RebootContainer rebootContainer

	Reboot the container by shutting it down, and starting it again. Applies pending changes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiRebootContainerRequest
	*/
	RebootContainer(ctx context.Context, node string, vmid int64) ApiRebootContainerRequest

	// RebootContainerExecute executes the request
	//  @return CreateVM200Response
	RebootContainerExecute(r ApiRebootContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	RebootVM rebootVM

	Reboot the VM by shutting it down, and starting it again. Applies pending changes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiRebootVMRequest
	*/
	RebootVM(ctx context.Context, node string, vmid int64) ApiRebootVMRequest

	// RebootVMExecute executes the request
	//  @return CreateVM200Response
	RebootVMExecute(r ApiRebootVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	ResizeContainerDisk resizeContainerDisk

	Resize a container mount point.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiResizeContainerDiskRequest
	*/
	ResizeContainerDisk(ctx context.Context, node string, vmid int64) ApiResizeContainerDiskRequest

	// ResizeContainerDiskExecute executes the request
	//  @return TaskStartResponse
	ResizeContainerDiskExecute(r ApiResizeContainerDiskRequest) (*TaskStartResponse, *http.Response, error)

	/*
	ResizeVMDisk resizeVMDisk

	Extend volume size.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiResizeVMDiskRequest
	*/
	ResizeVMDisk(ctx context.Context, node string, vmid int64) ApiResizeVMDiskRequest

	// ResizeVMDiskExecute executes the request
	//  @return TaskStartResponse
	ResizeVMDiskExecute(r ApiResizeVMDiskRequest) (*TaskStartResponse, *http.Response, error)

	/*
	ResumeContainer resumeContainer

	Resume the container.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiResumeContainerRequest
	*/
	ResumeContainer(ctx context.Context, node string, vmid int64) ApiResumeContainerRequest

	// ResumeContainerExecute executes the request
	//  @return CreateVM200Response
	ResumeContainerExecute(r ApiResumeContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	ResumeVM resumeVM

	Resume virtual machine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiResumeVMRequest
	*/
	ResumeVM(ctx context.Context, node string, vmid int64) ApiResumeVMRequest

	// ResumeVMExecute executes the request
	//  @return CreateVM200Response
	ResumeVMExecute(r ApiResumeVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	RollbackContainerSnapshot rollbackContainerSnapshot

	Rollback LXC state to specified snapshot.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param snapname snapname
	@param vmid vmid
	@return ApiRollbackContainerSnapshotRequest
	*/
	RollbackContainerSnapshot(ctx context.Context, node string, snapname string, vmid int64) ApiRollbackContainerSnapshotRequest

	// RollbackContainerSnapshotExecute executes the request
	//  @return TaskStartResponse
	RollbackContainerSnapshotExecute(r ApiRollbackContainerSnapshotRequest) (*TaskStartResponse, *http.Response, error)

	/*
	RollbackVMSnapshot rollbackVMSnapshot

	Rollback VM state to specified snapshot.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param snapname snapname
	@param vmid vmid
	@return ApiRollbackVMSnapshotRequest
	*/
	RollbackVMSnapshot(ctx context.Context, node string, snapname string, vmid int64) ApiRollbackVMSnapshotRequest

	// RollbackVMSnapshotExecute executes the request
	//  @return TaskStartResponse
	RollbackVMSnapshotExecute(r ApiRollbackVMSnapshotRequest) (*TaskStartResponse, *http.Response, error)

	/*
	ShutdownContainer shutdownContainer

	Shutdown the container. This will trigger a clean shutdown of the container, see lxc-stop(1) for details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiShutdownContainerRequest
	*/
	ShutdownContainer(ctx context.Context, node string, vmid int64) ApiShutdownContainerRequest

	// ShutdownContainerExecute executes the request
	//  @return CreateVM200Response
	ShutdownContainerExecute(r ApiShutdownContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	ShutdownVM shutdownVM

	Shutdown virtual machine. This is similar to pressing the power button on a physical machine. This will send an ACPI event for the guest OS, which should then proceed to a clean shutdown.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiShutdownVMRequest
	*/
	ShutdownVM(ctx context.Context, node string, vmid int64) ApiShutdownVMRequest

	// ShutdownVMExecute executes the request
	//  @return CreateVM200Response
	ShutdownVMExecute(r ApiShutdownVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	StartContainer startContainer

	Start the container.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiStartContainerRequest
	*/
	StartContainer(ctx context.Context, node string, vmid int64) ApiStartContainerRequest

	// StartContainerExecute executes the request
	//  @return CreateVM200Response
	StartContainerExecute(r ApiStartContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	StartVM startVM

	Start virtual machine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiStartVMRequest
	*/
	StartVM(ctx context.Context, node string, vmid int64) ApiStartVMRequest

	// StartVMExecute executes the request
	//  @return CreateVM200Response
	StartVMExecute(r ApiStartVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	StopContainer stopContainer

	Stop the container. This will abruptly stop all processes running in the container.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiStopContainerRequest
	*/
	StopContainer(ctx context.Context, node string, vmid int64) ApiStopContainerRequest

	// StopContainerExecute executes the request
	//  @return CreateVM200Response
	StopContainerExecute(r ApiStopContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	StopNodeTask stopNodeTask

	Stop a task.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param upid upid
	@return ApiStopNodeTaskRequest
	*/
	StopNodeTask(ctx context.Context, node string, upid string) ApiStopNodeTaskRequest

	// StopNodeTaskExecute executes the request
	//  @return CreateVM200Response
	StopNodeTaskExecute(r ApiStopNodeTaskRequest) (*CreateVM200Response, *http.Response, error)

	/*
	StopVM stopVM

	Stop virtual machine. The qemu process will exit immediately. This is akin to pulling the power plug of a running computer and may damage the VM data.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiStopVMRequest
	*/
	StopVM(ctx context.Context, node string, vmid int64) ApiStopVMRequest

	// StopVMExecute executes the request
	//  @return CreateVM200Response
	StopVMExecute(r ApiStopVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	SuspendContainer suspendContainer

	Suspend the container. This is experimental.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiSuspendContainerRequest
	*/
	SuspendContainer(ctx context.Context, node string, vmid int64) ApiSuspendContainerRequest

	// SuspendContainerExecute executes the request
	//  @return CreateVM200Response
	SuspendContainerExecute(r ApiSuspendContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	SuspendVM suspendVM

	Suspend virtual machine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiSuspendVMRequest
	*/
	SuspendVM(ctx context.Context, node string, vmid int64) ApiSuspendVMRequest

	// SuspendVMExecute executes the request
	//  @return CreateVM200Response
	SuspendVMExecute(r ApiSuspendVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	UpdateContainerConfigSync updateContainerConfigSync

	Set container options.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiUpdateContainerConfigSyncRequest
	*/
	UpdateContainerConfigSync(ctx context.Context, node string, vmid int64) ApiUpdateContainerConfigSyncRequest

	// UpdateContainerConfigSyncExecute executes the request
	//  @return CreateVM200Response
	UpdateContainerConfigSyncExecute(r ApiUpdateContainerConfigSyncRequest) (*CreateVM200Response, *http.Response, error)

	/*
	UpdateContainerSnapshotConfig updateContainerSnapshotConfig

	Update snapshot metadata.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param snapname snapname
	@param vmid vmid
	@return ApiUpdateContainerSnapshotConfigRequest
	*/
	UpdateContainerSnapshotConfig(ctx context.Context, node string, snapname string, vmid int64) ApiUpdateContainerSnapshotConfigRequest

	// UpdateContainerSnapshotConfigExecute executes the request
	//  @return CreateVM200Response
	UpdateContainerSnapshotConfigExecute(r ApiUpdateContainerSnapshotConfigRequest) (*CreateVM200Response, *http.Response, error)

	/*
	UpdateVMConfig updateVMConfig

	Set virtual machine options (asynchronous API).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiUpdateVMConfigRequest
	*/
	UpdateVMConfig(ctx context.Context, node string, vmid int64) ApiUpdateVMConfigRequest

	// UpdateVMConfigExecute executes the request
	//  @return CreateVM200Response
	UpdateVMConfigExecute(r ApiUpdateVMConfigRequest) (*CreateVM200Response, *http.Response, error)

	/*
	UpdateVMConfigSync updateVMConfigSync

	Set virtual machine options (synchronous API) - You should consider using the POST method instead for any actions involving hotplug or storage allocation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param vmid vmid
	@return ApiUpdateVMConfigSyncRequest
	*/
	UpdateVMConfigSync(ctx context.Context, node string, vmid int64) ApiUpdateVMConfigSyncRequest

	// UpdateVMConfigSyncExecute executes the request
	//  @return CreateVM200Response
	UpdateVMConfigSyncExecute(r ApiUpdateVMConfigSyncRequest) (*CreateVM200Response, *http.Response, error)

	/*
	UpdateVMSnapshotConfig updateVMSnapshotConfig

	Update snapshot metadata.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param snapname snapname
	@param vmid vmid
	@return ApiUpdateVMSnapshotConfigRequest
	*/
	UpdateVMSnapshotConfig(ctx context.Context, node string, snapname string, vmid int64) ApiUpdateVMSnapshotConfigRequest

	// UpdateVMSnapshotConfigExecute executes the request
	//  @return CreateVM200Response
	UpdateVMSnapshotConfigExecute(r ApiUpdateVMSnapshotConfigRequest) (*CreateVM200Response, *http.Response, error)

	/*
	UploadFile uploadFile

	Upload templates, ISO images and OVAs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node node
	@param storage storage
	@return ApiUploadFileRequest
	*/
	UploadFile(ctx context.Context, node string, storage string) ApiUploadFileRequest

	// UploadFileExecute executes the request
	//  @return CreateVM200Response
	UploadFileExecute(r ApiUploadFileRequest) (*CreateVM200Response, *http.Response, error)
}

// NodesApiService NodesApi service
type NodesApiService service

type ApiCreateContainerRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	createContainerRequest *CreateContainerRequest
}

func (r ApiCreateContainerRequest) CreateContainerRequest(createContainerRequest CreateContainerRequest) ApiCreateContainerRequest {
	r.createContainerRequest = &createContainerRequest
	return r
}

func (r ApiCreateContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.CreateContainerExecute(r)
}

/*
CreateContainer createContainer

Create or restore a container.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @return ApiCreateContainerRequest
*/
func (a *NodesApiService) CreateContainer(ctx context.Context, node string) ApiCreateContainerRequest {
	return ApiCreateContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) CreateContainerExecute(r ApiCreateContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.CreateContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createContainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateContainerSnapshotRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	createContainerSnapshotRequest *CreateContainerSnapshotRequest
}

func (r ApiCreateContainerSnapshotRequest) CreateContainerSnapshotRequest(createContainerSnapshotRequest CreateContainerSnapshotRequest) ApiCreateContainerSnapshotRequest {
	r.createContainerSnapshotRequest = &createContainerSnapshotRequest
	return r
}

func (r ApiCreateContainerSnapshotRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.CreateContainerSnapshotExecute(r)
}

/*
CreateContainerSnapshot createContainerSnapshot

Snapshot a container.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiCreateContainerSnapshotRequest
*/
func (a *NodesApiService) CreateContainerSnapshot(ctx context.Context, node string, vmid int64) ApiCreateContainerSnapshotRequest {
	return ApiCreateContainerSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesApiService) CreateContainerSnapshotExecute(r ApiCreateContainerSnapshotRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.CreateContainerSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createContainerSnapshotRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNodesSingleStorageSingleContentRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	storage string
	createNodesSingleStorageSingleContentRequest *CreateNodesSingleStorageSingleContentRequest
}

func (r ApiCreateNodesSingleStorageSingleContentRequest) CreateNodesSingleStorageSingleContentRequest(createNodesSingleStorageSingleContentRequest CreateNodesSingleStorageSingleContentRequest) ApiCreateNodesSingleStorageSingleContentRequest {
	r.createNodesSingleStorageSingleContentRequest = &createNodesSingleStorageSingleContentRequest
	return r
}

func (r ApiCreateNodesSingleStorageSingleContentRequest) Execute() (*CreateNodesSingleStorageSingleContent200Response, *http.Response, error) {
	return r.ApiService.CreateNodesSingleStorageSingleContentExecute(r)
}

/*
CreateNodesSingleStorageSingleContent createNodesSingleStorageSingleContent

Allocate disk images.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param storage storage
 @return ApiCreateNodesSingleStorageSingleContentRequest
*/
func (a *NodesApiService) CreateNodesSingleStorageSingleContent(ctx context.Context, node string, storage string) ApiCreateNodesSingleStorageSingleContentRequest {
	return ApiCreateNodesSingleStorageSingleContentRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		storage: storage,
	}
}

// Execute executes the request
//  @return CreateNodesSingleStorageSingleContent200Response
func (a *NodesApiService) CreateNodesSingleStorageSingleContentExecute(r ApiCreateNodesSingleStorageSingleContentRequest) (*CreateNodesSingleStorageSingleContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateNodesSingleStorageSingleContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.CreateNodesSingleStorageSingleContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/storage/{storage}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storage"+"}", url.PathEscape(parameterValueToString(r.storage, "storage")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createNodesSingleStorageSingleContentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVMRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	createVMRequest *CreateVMRequest
}

func (r ApiCreateVMRequest) CreateVMRequest(createVMRequest CreateVMRequest) ApiCreateVMRequest {
	r.createVMRequest = &createVMRequest
	return r
}

func (r ApiCreateVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.CreateVMExecute(r)
}

/*
CreateVM createVM

Create or restore a virtual machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @return ApiCreateVMRequest
*/
func (a *NodesApiService) CreateVM(ctx context.Context, node string) ApiCreateVMRequest {
	return ApiCreateVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) CreateVMExecute(r ApiCreateVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.CreateVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVMSnapshotRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	createVMSnapshotRequest *CreateVMSnapshotRequest
}

func (r ApiCreateVMSnapshotRequest) CreateVMSnapshotRequest(createVMSnapshotRequest CreateVMSnapshotRequest) ApiCreateVMSnapshotRequest {
	r.createVMSnapshotRequest = &createVMSnapshotRequest
	return r
}

func (r ApiCreateVMSnapshotRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.CreateVMSnapshotExecute(r)
}

/*
CreateVMSnapshot createVMSnapshot

Snapshot a VM.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiCreateVMSnapshotRequest
*/
func (a *NodesApiService) CreateVMSnapshot(ctx context.Context, node string, vmid int64) ApiCreateVMSnapshotRequest {
	return ApiCreateVMSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesApiService) CreateVMSnapshotExecute(r ApiCreateVMSnapshotRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.CreateVMSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVMSnapshotRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteContainerRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
}

func (r ApiDeleteContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.DeleteContainerExecute(r)
}

/*
DeleteContainer deleteContainer

Destroy the container (also delete all uses files).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiDeleteContainerRequest
*/
func (a *NodesApiService) DeleteContainer(ctx context.Context, node string, vmid int64) ApiDeleteContainerRequest {
	return ApiDeleteContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) DeleteContainerExecute(r ApiDeleteContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.DeleteContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteContainerSnapshotRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	snapname string
	vmid int64
}

func (r ApiDeleteContainerSnapshotRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.DeleteContainerSnapshotExecute(r)
}

/*
DeleteContainerSnapshot deleteContainerSnapshot

Delete a LXC snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param snapname snapname
 @param vmid vmid
 @return ApiDeleteContainerSnapshotRequest
*/
func (a *NodesApiService) DeleteContainerSnapshot(ctx context.Context, node string, snapname string, vmid int64) ApiDeleteContainerSnapshotRequest {
	return ApiDeleteContainerSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		snapname: snapname,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesApiService) DeleteContainerSnapshotExecute(r ApiDeleteContainerSnapshotRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.DeleteContainerSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot/{snapname}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVMRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
}

func (r ApiDeleteVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.DeleteVMExecute(r)
}

/*
DeleteVM deleteVM

Destroy the VM and  all used/owned volumes. Removes any VM specific permissions and firewall rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiDeleteVMRequest
*/
func (a *NodesApiService) DeleteVM(ctx context.Context, node string, vmid int64) ApiDeleteVMRequest {
	return ApiDeleteVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) DeleteVMExecute(r ApiDeleteVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.DeleteVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVMSnapshotRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	snapname string
	vmid int64
}

func (r ApiDeleteVMSnapshotRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.DeleteVMSnapshotExecute(r)
}

/*
DeleteVMSnapshot deleteVMSnapshot

Delete a VM snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param snapname snapname
 @param vmid vmid
 @return ApiDeleteVMSnapshotRequest
*/
func (a *NodesApiService) DeleteVMSnapshot(ctx context.Context, node string, snapname string, vmid int64) ApiDeleteVMSnapshotRequest {
	return ApiDeleteVMSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		snapname: snapname,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesApiService) DeleteVMSnapshotExecute(r ApiDeleteVMSnapshotRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.DeleteVMSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot/{snapname}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
}

func (r ApiGetContainerRequest) Execute() (*GetVM200Response, *http.Response, error) {
	return r.ApiService.GetContainerExecute(r)
}

/*
GetContainer getContainer

Directory index

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiGetContainerRequest
*/
func (a *NodesApiService) GetContainer(ctx context.Context, node string, vmid int64) ApiGetContainerRequest {
	return ApiGetContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVM200Response
func (a *NodesApiService) GetContainerExecute(r ApiGetContainerRequest) (*GetVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerConfigRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
}

func (r ApiGetContainerConfigRequest) Execute() (*GetContainerConfig200Response, *http.Response, error) {
	return r.ApiService.GetContainerConfigExecute(r)
}

/*
GetContainerConfig getContainerConfig

Get container configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiGetContainerConfigRequest
*/
func (a *NodesApiService) GetContainerConfig(ctx context.Context, node string, vmid int64) ApiGetContainerConfigRequest {
	return ApiGetContainerConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetContainerConfig200Response
func (a *NodesApiService) GetContainerConfigExecute(r ApiGetContainerConfigRequest) (*GetContainerConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContainerConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetContainerConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerConfigPendingRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
}

func (r ApiGetContainerConfigPendingRequest) Execute() (*GetContainerConfigPending200Response, *http.Response, error) {
	return r.ApiService.GetContainerConfigPendingExecute(r)
}

/*
GetContainerConfigPending getContainerConfigPending

Get container configuration, including pending changes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiGetContainerConfigPendingRequest
*/
func (a *NodesApiService) GetContainerConfigPending(ctx context.Context, node string, vmid int64) ApiGetContainerConfigPendingRequest {
	return ApiGetContainerConfigPendingRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetContainerConfigPending200Response
func (a *NodesApiService) GetContainerConfigPendingExecute(r ApiGetContainerConfigPendingRequest) (*GetContainerConfigPending200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContainerConfigPending200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetContainerConfigPending")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/pending"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerSnapshotRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	snapname string
	vmid int64
}

func (r ApiGetContainerSnapshotRequest) Execute() (*GetVMSnapshot200Response, *http.Response, error) {
	return r.ApiService.GetContainerSnapshotExecute(r)
}

/*
GetContainerSnapshot getContainerSnapshot



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param snapname snapname
 @param vmid vmid
 @return ApiGetContainerSnapshotRequest
*/
func (a *NodesApiService) GetContainerSnapshot(ctx context.Context, node string, snapname string, vmid int64) ApiGetContainerSnapshotRequest {
	return ApiGetContainerSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		snapname: snapname,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVMSnapshot200Response
func (a *NodesApiService) GetContainerSnapshotExecute(r ApiGetContainerSnapshotRequest) (*GetVMSnapshot200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMSnapshot200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetContainerSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot/{snapname}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerSnapshotConfigRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	snapname string
	vmid int64
}

func (r ApiGetContainerSnapshotConfigRequest) Execute() (*GetVMSnapshotConfig200Response, *http.Response, error) {
	return r.ApiService.GetContainerSnapshotConfigExecute(r)
}

/*
GetContainerSnapshotConfig getContainerSnapshotConfig

Get snapshot configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param snapname snapname
 @param vmid vmid
 @return ApiGetContainerSnapshotConfigRequest
*/
func (a *NodesApiService) GetContainerSnapshotConfig(ctx context.Context, node string, snapname string, vmid int64) ApiGetContainerSnapshotConfigRequest {
	return ApiGetContainerSnapshotConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		snapname: snapname,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVMSnapshotConfig200Response
func (a *NodesApiService) GetContainerSnapshotConfigExecute(r ApiGetContainerSnapshotConfigRequest) (*GetVMSnapshotConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMSnapshotConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetContainerSnapshotConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot/{snapname}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerSnapshotsRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
}

func (r ApiGetContainerSnapshotsRequest) Execute() (*GetContainerSnapshots200Response, *http.Response, error) {
	return r.ApiService.GetContainerSnapshotsExecute(r)
}

/*
GetContainerSnapshots getContainerSnapshots

List all snapshots.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiGetContainerSnapshotsRequest
*/
func (a *NodesApiService) GetContainerSnapshots(ctx context.Context, node string, vmid int64) ApiGetContainerSnapshotsRequest {
	return ApiGetContainerSnapshotsRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetContainerSnapshots200Response
func (a *NodesApiService) GetContainerSnapshotsExecute(r ApiGetContainerSnapshotsRequest) (*GetContainerSnapshots200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContainerSnapshots200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetContainerSnapshots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerStatusRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
}

func (r ApiGetContainerStatusRequest) Execute() (*GetVM200Response, *http.Response, error) {
	return r.ApiService.GetContainerStatusExecute(r)
}

/*
GetContainerStatus getContainerStatus

Directory index

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiGetContainerStatusRequest
*/
func (a *NodesApiService) GetContainerStatus(ctx context.Context, node string, vmid int64) ApiGetContainerStatusRequest {
	return ApiGetContainerStatusRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVM200Response
func (a *NodesApiService) GetContainerStatusExecute(r ApiGetContainerStatusRequest) (*GetVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetContainerStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainersRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
}

func (r ApiGetContainersRequest) Execute() (*GetContainers200Response, *http.Response, error) {
	return r.ApiService.GetContainersExecute(r)
}

/*
GetContainers getContainers

LXC container index (per node).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @return ApiGetContainersRequest
*/
func (a *NodesApiService) GetContainers(ctx context.Context, node string) ApiGetContainersRequest {
	return ApiGetContainersRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
	}
}

// Execute executes the request
//  @return GetContainers200Response
func (a *NodesApiService) GetContainersExecute(r ApiGetContainersRequest) (*GetContainers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContainers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetContainers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrentContainerStatusRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
}

func (r ApiGetCurrentContainerStatusRequest) Execute() (*GetCurrentContainerStatus200Response, *http.Response, error) {
	return r.ApiService.GetCurrentContainerStatusExecute(r)
}

/*
GetCurrentContainerStatus getCurrentContainerStatus

Get virtual machine status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiGetCurrentContainerStatusRequest
*/
func (a *NodesApiService) GetCurrentContainerStatus(ctx context.Context, node string, vmid int64) ApiGetCurrentContainerStatusRequest {
	return ApiGetCurrentContainerStatusRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetCurrentContainerStatus200Response
func (a *NodesApiService) GetCurrentContainerStatusExecute(r ApiGetCurrentContainerStatusRequest) (*GetCurrentContainerStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCurrentContainerStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetCurrentContainerStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/current"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrentVMStatusRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
}

func (r ApiGetCurrentVMStatusRequest) Execute() (*GetCurrentVMStatus200Response, *http.Response, error) {
	return r.ApiService.GetCurrentVMStatusExecute(r)
}

/*
GetCurrentVMStatus getCurrentVMStatus

Get virtual machine status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiGetCurrentVMStatusRequest
*/
func (a *NodesApiService) GetCurrentVMStatus(ctx context.Context, node string, vmid int64) ApiGetCurrentVMStatusRequest {
	return ApiGetCurrentVMStatusRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetCurrentVMStatus200Response
func (a *NodesApiService) GetCurrentVMStatusExecute(r ApiGetCurrentVMStatusRequest) (*GetCurrentVMStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCurrentVMStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetCurrentVMStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/current"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeTaskRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	upid string
}

func (r ApiGetNodeTaskRequest) Execute() (*GetVMSnapshot200Response, *http.Response, error) {
	return r.ApiService.GetNodeTaskExecute(r)
}

/*
GetNodeTask getNodeTask



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param upid upid
 @return ApiGetNodeTaskRequest
*/
func (a *NodesApiService) GetNodeTask(ctx context.Context, node string, upid string) ApiGetNodeTaskRequest {
	return ApiGetNodeTaskRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		upid: upid,
	}
}

// Execute executes the request
//  @return GetVMSnapshot200Response
func (a *NodesApiService) GetNodeTaskExecute(r ApiGetNodeTaskRequest) (*GetVMSnapshot200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMSnapshot200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetNodeTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/tasks/{upid}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upid"+"}", url.PathEscape(parameterValueToString(r.upid, "upid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeTaskLogRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	upid string
}

func (r ApiGetNodeTaskLogRequest) Execute() (*GetNodeTaskLog200Response, *http.Response, error) {
	return r.ApiService.GetNodeTaskLogExecute(r)
}

/*
GetNodeTaskLog getNodeTaskLog

Read task log.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param upid upid
 @return ApiGetNodeTaskLogRequest
*/
func (a *NodesApiService) GetNodeTaskLog(ctx context.Context, node string, upid string) ApiGetNodeTaskLogRequest {
	return ApiGetNodeTaskLogRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		upid: upid,
	}
}

// Execute executes the request
//  @return GetNodeTaskLog200Response
func (a *NodesApiService) GetNodeTaskLogExecute(r ApiGetNodeTaskLogRequest) (*GetNodeTaskLog200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeTaskLog200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetNodeTaskLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/tasks/{upid}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upid"+"}", url.PathEscape(parameterValueToString(r.upid, "upid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeTaskStatusRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	upid string
}

func (r ApiGetNodeTaskStatusRequest) Execute() (*GetNodeTaskStatus200Response, *http.Response, error) {
	return r.ApiService.GetNodeTaskStatusExecute(r)
}

/*
GetNodeTaskStatus getNodeTaskStatus

Read task status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param upid upid
 @return ApiGetNodeTaskStatusRequest
*/
func (a *NodesApiService) GetNodeTaskStatus(ctx context.Context, node string, upid string) ApiGetNodeTaskStatusRequest {
	return ApiGetNodeTaskStatusRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		upid: upid,
	}
}

// Execute executes the request
//  @return GetNodeTaskStatus200Response
func (a *NodesApiService) GetNodeTaskStatusExecute(r ApiGetNodeTaskStatusRequest) (*GetNodeTaskStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeTaskStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetNodeTaskStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/tasks/{upid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upid"+"}", url.PathEscape(parameterValueToString(r.upid, "upid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeTasksRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
}

func (r ApiGetNodeTasksRequest) Execute() (*GetNodeTasks200Response, *http.Response, error) {
	return r.ApiService.GetNodeTasksExecute(r)
}

/*
GetNodeTasks getNodeTasks

Read task list for one node (finished tasks).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @return ApiGetNodeTasksRequest
*/
func (a *NodesApiService) GetNodeTasks(ctx context.Context, node string) ApiGetNodeTasksRequest {
	return ApiGetNodeTasksRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
	}
}

// Execute executes the request
//  @return GetNodeTasks200Response
func (a *NodesApiService) GetNodeTasksExecute(r ApiGetNodeTasksRequest) (*GetNodeTasks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeTasks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetNodeTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStorageContentRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	storage string
}

func (r ApiGetStorageContentRequest) Execute() (*GetStorageContent200Response, *http.Response, error) {
	return r.ApiService.GetStorageContentExecute(r)
}

/*
GetStorageContent getStorageContent

List storage content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param storage storage
 @return ApiGetStorageContentRequest
*/
func (a *NodesApiService) GetStorageContent(ctx context.Context, node string, storage string) ApiGetStorageContentRequest {
	return ApiGetStorageContentRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		storage: storage,
	}
}

// Execute executes the request
//  @return GetStorageContent200Response
func (a *NodesApiService) GetStorageContentExecute(r ApiGetStorageContentRequest) (*GetStorageContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetStorageContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetStorageContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/storage/{storage}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storage"+"}", url.PathEscape(parameterValueToString(r.storage, "storage")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStoragesRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
}

func (r ApiGetStoragesRequest) Execute() (*GetStorages200Response, *http.Response, error) {
	return r.ApiService.GetStoragesExecute(r)
}

/*
GetStorages getStorages

Get status for all datastores.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @return ApiGetStoragesRequest
*/
func (a *NodesApiService) GetStorages(ctx context.Context, node string) ApiGetStoragesRequest {
	return ApiGetStoragesRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
	}
}

// Execute executes the request
//  @return GetStorages200Response
func (a *NodesApiService) GetStoragesExecute(r ApiGetStoragesRequest) (*GetStorages200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetStorages200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetStorages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/storage"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
}

func (r ApiGetVMRequest) Execute() (*GetVM200Response, *http.Response, error) {
	return r.ApiService.GetVMExecute(r)
}

/*
GetVM getVM

Directory index

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiGetVMRequest
*/
func (a *NodesApiService) GetVM(ctx context.Context, node string, vmid int64) ApiGetVMRequest {
	return ApiGetVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVM200Response
func (a *NodesApiService) GetVMExecute(r ApiGetVMRequest) (*GetVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMConfigRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
}

func (r ApiGetVMConfigRequest) Execute() (*GetVMConfig200Response, *http.Response, error) {
	return r.ApiService.GetVMConfigExecute(r)
}

/*
GetVMConfig getVMConfig

Get the virtual machine configuration with pending configuration changes applied. Set the 'current' parameter to get the current configuration instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiGetVMConfigRequest
*/
func (a *NodesApiService) GetVMConfig(ctx context.Context, node string, vmid int64) ApiGetVMConfigRequest {
	return ApiGetVMConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVMConfig200Response
func (a *NodesApiService) GetVMConfigExecute(r ApiGetVMConfigRequest) (*GetVMConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetVMConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMConfigPendingRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
}

func (r ApiGetVMConfigPendingRequest) Execute() (*GetVMConfigPending200Response, *http.Response, error) {
	return r.ApiService.GetVMConfigPendingExecute(r)
}

/*
GetVMConfigPending getVMConfigPending

Get the virtual machine configuration with both current and pending values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiGetVMConfigPendingRequest
*/
func (a *NodesApiService) GetVMConfigPending(ctx context.Context, node string, vmid int64) ApiGetVMConfigPendingRequest {
	return ApiGetVMConfigPendingRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVMConfigPending200Response
func (a *NodesApiService) GetVMConfigPendingExecute(r ApiGetVMConfigPendingRequest) (*GetVMConfigPending200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMConfigPending200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetVMConfigPending")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/pending"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMSnapshotRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	snapname string
	vmid int64
}

func (r ApiGetVMSnapshotRequest) Execute() (*GetVMSnapshot200Response, *http.Response, error) {
	return r.ApiService.GetVMSnapshotExecute(r)
}

/*
GetVMSnapshot getVMSnapshot



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param snapname snapname
 @param vmid vmid
 @return ApiGetVMSnapshotRequest
*/
func (a *NodesApiService) GetVMSnapshot(ctx context.Context, node string, snapname string, vmid int64) ApiGetVMSnapshotRequest {
	return ApiGetVMSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		snapname: snapname,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVMSnapshot200Response
func (a *NodesApiService) GetVMSnapshotExecute(r ApiGetVMSnapshotRequest) (*GetVMSnapshot200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMSnapshot200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetVMSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot/{snapname}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMSnapshotConfigRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	snapname string
	vmid int64
}

func (r ApiGetVMSnapshotConfigRequest) Execute() (*GetVMSnapshotConfig200Response, *http.Response, error) {
	return r.ApiService.GetVMSnapshotConfigExecute(r)
}

/*
GetVMSnapshotConfig getVMSnapshotConfig

Get snapshot configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param snapname snapname
 @param vmid vmid
 @return ApiGetVMSnapshotConfigRequest
*/
func (a *NodesApiService) GetVMSnapshotConfig(ctx context.Context, node string, snapname string, vmid int64) ApiGetVMSnapshotConfigRequest {
	return ApiGetVMSnapshotConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		snapname: snapname,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVMSnapshotConfig200Response
func (a *NodesApiService) GetVMSnapshotConfigExecute(r ApiGetVMSnapshotConfigRequest) (*GetVMSnapshotConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMSnapshotConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetVMSnapshotConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot/{snapname}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMSnapshotsRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
}

func (r ApiGetVMSnapshotsRequest) Execute() (*GetVMSnapshots200Response, *http.Response, error) {
	return r.ApiService.GetVMSnapshotsExecute(r)
}

/*
GetVMSnapshots getVMSnapshots

List all snapshots.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiGetVMSnapshotsRequest
*/
func (a *NodesApiService) GetVMSnapshots(ctx context.Context, node string, vmid int64) ApiGetVMSnapshotsRequest {
	return ApiGetVMSnapshotsRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVMSnapshots200Response
func (a *NodesApiService) GetVMSnapshotsExecute(r ApiGetVMSnapshotsRequest) (*GetVMSnapshots200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMSnapshots200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetVMSnapshots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMsRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
}

func (r ApiGetVMsRequest) Execute() (*GetVMs200Response, *http.Response, error) {
	return r.ApiService.GetVMsExecute(r)
}

/*
GetVMs getVMs

Virtual machine index (per node).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @return ApiGetVMsRequest
*/
func (a *NodesApiService) GetVMs(ctx context.Context, node string) ApiGetVMsRequest {
	return ApiGetVMsRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
	}
}

// Execute executes the request
//  @return GetVMs200Response
func (a *NodesApiService) GetVMsExecute(r ApiGetVMsRequest) (*GetVMs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.GetVMs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRebootContainerRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	rebootContainerRequest *RebootContainerRequest
}

func (r ApiRebootContainerRequest) RebootContainerRequest(rebootContainerRequest RebootContainerRequest) ApiRebootContainerRequest {
	r.rebootContainerRequest = &rebootContainerRequest
	return r
}

func (r ApiRebootContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.RebootContainerExecute(r)
}

/*
RebootContainer rebootContainer

Reboot the container by shutting it down, and starting it again. Applies pending changes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiRebootContainerRequest
*/
func (a *NodesApiService) RebootContainer(ctx context.Context, node string, vmid int64) ApiRebootContainerRequest {
	return ApiRebootContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) RebootContainerExecute(r ApiRebootContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.RebootContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/reboot"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rebootContainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRebootVMRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	rebootVMRequest *RebootVMRequest
}

func (r ApiRebootVMRequest) RebootVMRequest(rebootVMRequest RebootVMRequest) ApiRebootVMRequest {
	r.rebootVMRequest = &rebootVMRequest
	return r
}

func (r ApiRebootVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.RebootVMExecute(r)
}

/*
RebootVM rebootVM

Reboot the VM by shutting it down, and starting it again. Applies pending changes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiRebootVMRequest
*/
func (a *NodesApiService) RebootVM(ctx context.Context, node string, vmid int64) ApiRebootVMRequest {
	return ApiRebootVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) RebootVMExecute(r ApiRebootVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.RebootVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/reboot"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rebootVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResizeContainerDiskRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	resizeContainerDiskRequest *ResizeContainerDiskRequest
}

func (r ApiResizeContainerDiskRequest) ResizeContainerDiskRequest(resizeContainerDiskRequest ResizeContainerDiskRequest) ApiResizeContainerDiskRequest {
	r.resizeContainerDiskRequest = &resizeContainerDiskRequest
	return r
}

func (r ApiResizeContainerDiskRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.ResizeContainerDiskExecute(r)
}

/*
ResizeContainerDisk resizeContainerDisk

Resize a container mount point.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiResizeContainerDiskRequest
*/
func (a *NodesApiService) ResizeContainerDisk(ctx context.Context, node string, vmid int64) ApiResizeContainerDiskRequest {
	return ApiResizeContainerDiskRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesApiService) ResizeContainerDiskExecute(r ApiResizeContainerDiskRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.ResizeContainerDisk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/resize"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resizeContainerDiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResizeVMDiskRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	resizeVMDiskRequest *ResizeVMDiskRequest
}

func (r ApiResizeVMDiskRequest) ResizeVMDiskRequest(resizeVMDiskRequest ResizeVMDiskRequest) ApiResizeVMDiskRequest {
	r.resizeVMDiskRequest = &resizeVMDiskRequest
	return r
}

func (r ApiResizeVMDiskRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.ResizeVMDiskExecute(r)
}

/*
ResizeVMDisk resizeVMDisk

Extend volume size.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiResizeVMDiskRequest
*/
func (a *NodesApiService) ResizeVMDisk(ctx context.Context, node string, vmid int64) ApiResizeVMDiskRequest {
	return ApiResizeVMDiskRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesApiService) ResizeVMDiskExecute(r ApiResizeVMDiskRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.ResizeVMDisk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/resize"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resizeVMDiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeContainerRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	body *map[string]interface{}
}

func (r ApiResumeContainerRequest) Body(body map[string]interface{}) ApiResumeContainerRequest {
	r.body = &body
	return r
}

func (r ApiResumeContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.ResumeContainerExecute(r)
}

/*
ResumeContainer resumeContainer

Resume the container.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiResumeContainerRequest
*/
func (a *NodesApiService) ResumeContainer(ctx context.Context, node string, vmid int64) ApiResumeContainerRequest {
	return ApiResumeContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) ResumeContainerExecute(r ApiResumeContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.ResumeContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/resume"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeVMRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	resumeVMRequest *ResumeVMRequest
}

func (r ApiResumeVMRequest) ResumeVMRequest(resumeVMRequest ResumeVMRequest) ApiResumeVMRequest {
	r.resumeVMRequest = &resumeVMRequest
	return r
}

func (r ApiResumeVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.ResumeVMExecute(r)
}

/*
ResumeVM resumeVM

Resume virtual machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiResumeVMRequest
*/
func (a *NodesApiService) ResumeVM(ctx context.Context, node string, vmid int64) ApiResumeVMRequest {
	return ApiResumeVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) ResumeVMExecute(r ApiResumeVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.ResumeVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/resume"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resumeVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRollbackContainerSnapshotRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	snapname string
	vmid int64
	rollbackContainerSnapshotRequest *RollbackContainerSnapshotRequest
}

func (r ApiRollbackContainerSnapshotRequest) RollbackContainerSnapshotRequest(rollbackContainerSnapshotRequest RollbackContainerSnapshotRequest) ApiRollbackContainerSnapshotRequest {
	r.rollbackContainerSnapshotRequest = &rollbackContainerSnapshotRequest
	return r
}

func (r ApiRollbackContainerSnapshotRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.RollbackContainerSnapshotExecute(r)
}

/*
RollbackContainerSnapshot rollbackContainerSnapshot

Rollback LXC state to specified snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param snapname snapname
 @param vmid vmid
 @return ApiRollbackContainerSnapshotRequest
*/
func (a *NodesApiService) RollbackContainerSnapshot(ctx context.Context, node string, snapname string, vmid int64) ApiRollbackContainerSnapshotRequest {
	return ApiRollbackContainerSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		snapname: snapname,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesApiService) RollbackContainerSnapshotExecute(r ApiRollbackContainerSnapshotRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.RollbackContainerSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot/{snapname}/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rollbackContainerSnapshotRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRollbackVMSnapshotRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	snapname string
	vmid int64
	rollbackVMSnapshotRequest *RollbackVMSnapshotRequest
}

func (r ApiRollbackVMSnapshotRequest) RollbackVMSnapshotRequest(rollbackVMSnapshotRequest RollbackVMSnapshotRequest) ApiRollbackVMSnapshotRequest {
	r.rollbackVMSnapshotRequest = &rollbackVMSnapshotRequest
	return r
}

func (r ApiRollbackVMSnapshotRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.RollbackVMSnapshotExecute(r)
}

/*
RollbackVMSnapshot rollbackVMSnapshot

Rollback VM state to specified snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param snapname snapname
 @param vmid vmid
 @return ApiRollbackVMSnapshotRequest
*/
func (a *NodesApiService) RollbackVMSnapshot(ctx context.Context, node string, snapname string, vmid int64) ApiRollbackVMSnapshotRequest {
	return ApiRollbackVMSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		snapname: snapname,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesApiService) RollbackVMSnapshotExecute(r ApiRollbackVMSnapshotRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.RollbackVMSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot/{snapname}/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rollbackVMSnapshotRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShutdownContainerRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	shutdownContainerRequest *ShutdownContainerRequest
}

func (r ApiShutdownContainerRequest) ShutdownContainerRequest(shutdownContainerRequest ShutdownContainerRequest) ApiShutdownContainerRequest {
	r.shutdownContainerRequest = &shutdownContainerRequest
	return r
}

func (r ApiShutdownContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.ShutdownContainerExecute(r)
}

/*
ShutdownContainer shutdownContainer

Shutdown the container. This will trigger a clean shutdown of the container, see lxc-stop(1) for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiShutdownContainerRequest
*/
func (a *NodesApiService) ShutdownContainer(ctx context.Context, node string, vmid int64) ApiShutdownContainerRequest {
	return ApiShutdownContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) ShutdownContainerExecute(r ApiShutdownContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.ShutdownContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/shutdown"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.shutdownContainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShutdownVMRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	shutdownVMRequest *ShutdownVMRequest
}

func (r ApiShutdownVMRequest) ShutdownVMRequest(shutdownVMRequest ShutdownVMRequest) ApiShutdownVMRequest {
	r.shutdownVMRequest = &shutdownVMRequest
	return r
}

func (r ApiShutdownVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.ShutdownVMExecute(r)
}

/*
ShutdownVM shutdownVM

Shutdown virtual machine. This is similar to pressing the power button on a physical machine. This will send an ACPI event for the guest OS, which should then proceed to a clean shutdown.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiShutdownVMRequest
*/
func (a *NodesApiService) ShutdownVM(ctx context.Context, node string, vmid int64) ApiShutdownVMRequest {
	return ApiShutdownVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) ShutdownVMExecute(r ApiShutdownVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.ShutdownVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/shutdown"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.shutdownVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartContainerRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	startContainerRequest *StartContainerRequest
}

func (r ApiStartContainerRequest) StartContainerRequest(startContainerRequest StartContainerRequest) ApiStartContainerRequest {
	r.startContainerRequest = &startContainerRequest
	return r
}

func (r ApiStartContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.StartContainerExecute(r)
}

/*
StartContainer startContainer

Start the container.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiStartContainerRequest
*/
func (a *NodesApiService) StartContainer(ctx context.Context, node string, vmid int64) ApiStartContainerRequest {
	return ApiStartContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) StartContainerExecute(r ApiStartContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.StartContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/start"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startContainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartVMRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	startVMRequest *StartVMRequest
}

func (r ApiStartVMRequest) StartVMRequest(startVMRequest StartVMRequest) ApiStartVMRequest {
	r.startVMRequest = &startVMRequest
	return r
}

func (r ApiStartVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.StartVMExecute(r)
}

/*
StartVM startVM

Start virtual machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiStartVMRequest
*/
func (a *NodesApiService) StartVM(ctx context.Context, node string, vmid int64) ApiStartVMRequest {
	return ApiStartVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) StartVMExecute(r ApiStartVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.StartVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/start"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopContainerRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	stopContainerRequest *StopContainerRequest
}

func (r ApiStopContainerRequest) StopContainerRequest(stopContainerRequest StopContainerRequest) ApiStopContainerRequest {
	r.stopContainerRequest = &stopContainerRequest
	return r
}

func (r ApiStopContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.StopContainerExecute(r)
}

/*
StopContainer stopContainer

Stop the container. This will abruptly stop all processes running in the container.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiStopContainerRequest
*/
func (a *NodesApiService) StopContainer(ctx context.Context, node string, vmid int64) ApiStopContainerRequest {
	return ApiStopContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) StopContainerExecute(r ApiStopContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.StopContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stopContainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopNodeTaskRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	upid string
}

func (r ApiStopNodeTaskRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.StopNodeTaskExecute(r)
}

/*
StopNodeTask stopNodeTask

Stop a task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param upid upid
 @return ApiStopNodeTaskRequest
*/
func (a *NodesApiService) StopNodeTask(ctx context.Context, node string, upid string) ApiStopNodeTaskRequest {
	return ApiStopNodeTaskRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		upid: upid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) StopNodeTaskExecute(r ApiStopNodeTaskRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.StopNodeTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/tasks/{upid}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upid"+"}", url.PathEscape(parameterValueToString(r.upid, "upid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopVMRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	stopVMRequest *StopVMRequest
}

func (r ApiStopVMRequest) StopVMRequest(stopVMRequest StopVMRequest) ApiStopVMRequest {
	r.stopVMRequest = &stopVMRequest
	return r
}

func (r ApiStopVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.StopVMExecute(r)
}

/*
StopVM stopVM

Stop virtual machine. The qemu process will exit immediately. This is akin to pulling the power plug of a running computer and may damage the VM data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiStopVMRequest
*/
func (a *NodesApiService) StopVM(ctx context.Context, node string, vmid int64) ApiStopVMRequest {
	return ApiStopVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) StopVMExecute(r ApiStopVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.StopVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stopVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuspendContainerRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	body *map[string]interface{}
}

func (r ApiSuspendContainerRequest) Body(body map[string]interface{}) ApiSuspendContainerRequest {
	r.body = &body
	return r
}

func (r ApiSuspendContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.SuspendContainerExecute(r)
}

/*
SuspendContainer suspendContainer

Suspend the container. This is experimental.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiSuspendContainerRequest
*/
func (a *NodesApiService) SuspendContainer(ctx context.Context, node string, vmid int64) ApiSuspendContainerRequest {
	return ApiSuspendContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) SuspendContainerExecute(r ApiSuspendContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.SuspendContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/suspend"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuspendVMRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	suspendVMRequest *SuspendVMRequest
}

func (r ApiSuspendVMRequest) SuspendVMRequest(suspendVMRequest SuspendVMRequest) ApiSuspendVMRequest {
	r.suspendVMRequest = &suspendVMRequest
	return r
}

func (r ApiSuspendVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.SuspendVMExecute(r)
}

/*
SuspendVM suspendVM

Suspend virtual machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiSuspendVMRequest
*/
func (a *NodesApiService) SuspendVM(ctx context.Context, node string, vmid int64) ApiSuspendVMRequest {
	return ApiSuspendVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) SuspendVMExecute(r ApiSuspendVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.SuspendVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/suspend"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.suspendVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateContainerConfigSyncRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	updateContainerConfigSyncRequest *UpdateContainerConfigSyncRequest
}

func (r ApiUpdateContainerConfigSyncRequest) UpdateContainerConfigSyncRequest(updateContainerConfigSyncRequest UpdateContainerConfigSyncRequest) ApiUpdateContainerConfigSyncRequest {
	r.updateContainerConfigSyncRequest = &updateContainerConfigSyncRequest
	return r
}

func (r ApiUpdateContainerConfigSyncRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.UpdateContainerConfigSyncExecute(r)
}

/*
UpdateContainerConfigSync updateContainerConfigSync

Set container options.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiUpdateContainerConfigSyncRequest
*/
func (a *NodesApiService) UpdateContainerConfigSync(ctx context.Context, node string, vmid int64) ApiUpdateContainerConfigSyncRequest {
	return ApiUpdateContainerConfigSyncRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) UpdateContainerConfigSyncExecute(r ApiUpdateContainerConfigSyncRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.UpdateContainerConfigSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateContainerConfigSyncRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateContainerSnapshotConfigRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	snapname string
	vmid int64
	updateContainerSnapshotConfigRequest *UpdateContainerSnapshotConfigRequest
}

func (r ApiUpdateContainerSnapshotConfigRequest) UpdateContainerSnapshotConfigRequest(updateContainerSnapshotConfigRequest UpdateContainerSnapshotConfigRequest) ApiUpdateContainerSnapshotConfigRequest {
	r.updateContainerSnapshotConfigRequest = &updateContainerSnapshotConfigRequest
	return r
}

func (r ApiUpdateContainerSnapshotConfigRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.UpdateContainerSnapshotConfigExecute(r)
}

/*
UpdateContainerSnapshotConfig updateContainerSnapshotConfig

Update snapshot metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param snapname snapname
 @param vmid vmid
 @return ApiUpdateContainerSnapshotConfigRequest
*/
func (a *NodesApiService) UpdateContainerSnapshotConfig(ctx context.Context, node string, snapname string, vmid int64) ApiUpdateContainerSnapshotConfigRequest {
	return ApiUpdateContainerSnapshotConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		snapname: snapname,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) UpdateContainerSnapshotConfigExecute(r ApiUpdateContainerSnapshotConfigRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.UpdateContainerSnapshotConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot/{snapname}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateContainerSnapshotConfigRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVMConfigRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	updateVMConfigRequest *UpdateVMConfigRequest
}

func (r ApiUpdateVMConfigRequest) UpdateVMConfigRequest(updateVMConfigRequest UpdateVMConfigRequest) ApiUpdateVMConfigRequest {
	r.updateVMConfigRequest = &updateVMConfigRequest
	return r
}

func (r ApiUpdateVMConfigRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.UpdateVMConfigExecute(r)
}

/*
UpdateVMConfig updateVMConfig

Set virtual machine options (asynchronous API).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiUpdateVMConfigRequest
*/
func (a *NodesApiService) UpdateVMConfig(ctx context.Context, node string, vmid int64) ApiUpdateVMConfigRequest {
	return ApiUpdateVMConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) UpdateVMConfigExecute(r ApiUpdateVMConfigRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.UpdateVMConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateVMConfigRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVMConfigSyncRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	vmid int64
	updateVMConfigSyncRequest *UpdateVMConfigSyncRequest
}

func (r ApiUpdateVMConfigSyncRequest) UpdateVMConfigSyncRequest(updateVMConfigSyncRequest UpdateVMConfigSyncRequest) ApiUpdateVMConfigSyncRequest {
	r.updateVMConfigSyncRequest = &updateVMConfigSyncRequest
	return r
}

func (r ApiUpdateVMConfigSyncRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.UpdateVMConfigSyncExecute(r)
}

/*
UpdateVMConfigSync updateVMConfigSync

Set virtual machine options (synchronous API) - You should consider using the POST method instead for any actions involving hotplug or storage allocation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param vmid vmid
 @return ApiUpdateVMConfigSyncRequest
*/
func (a *NodesApiService) UpdateVMConfigSync(ctx context.Context, node string, vmid int64) ApiUpdateVMConfigSyncRequest {
	return ApiUpdateVMConfigSyncRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) UpdateVMConfigSyncExecute(r ApiUpdateVMConfigSyncRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.UpdateVMConfigSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateVMConfigSyncRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVMSnapshotConfigRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	snapname string
	vmid int64
	updateVMSnapshotConfigRequest *UpdateVMSnapshotConfigRequest
}

func (r ApiUpdateVMSnapshotConfigRequest) UpdateVMSnapshotConfigRequest(updateVMSnapshotConfigRequest UpdateVMSnapshotConfigRequest) ApiUpdateVMSnapshotConfigRequest {
	r.updateVMSnapshotConfigRequest = &updateVMSnapshotConfigRequest
	return r
}

func (r ApiUpdateVMSnapshotConfigRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.UpdateVMSnapshotConfigExecute(r)
}

/*
UpdateVMSnapshotConfig updateVMSnapshotConfig

Update snapshot metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param snapname snapname
 @param vmid vmid
 @return ApiUpdateVMSnapshotConfigRequest
*/
func (a *NodesApiService) UpdateVMSnapshotConfig(ctx context.Context, node string, snapname string, vmid int64) ApiUpdateVMSnapshotConfigRequest {
	return ApiUpdateVMSnapshotConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		snapname: snapname,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) UpdateVMSnapshotConfigExecute(r ApiUpdateVMSnapshotConfigRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.UpdateVMSnapshotConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot/{snapname}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateVMSnapshotConfigRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadFileRequest struct {
	ctx context.Context
	ApiService NodesApi
	node string
	storage string
	content *string
	filename *os.File
	checksum *string
	checksumAlgorithm *string
	tmpfilename *string
}

// Content type.
func (r ApiUploadFileRequest) Content(content string) ApiUploadFileRequest {
	r.content = &content
	return r
}

func (r ApiUploadFileRequest) Filename(filename *os.File) ApiUploadFileRequest {
	r.filename = filename
	return r
}

// The expected checksum of the file.
func (r ApiUploadFileRequest) Checksum(checksum string) ApiUploadFileRequest {
	r.checksum = &checksum
	return r
}

// The algorithm to calculate the checksum of the file.
func (r ApiUploadFileRequest) ChecksumAlgorithm(checksumAlgorithm string) ApiUploadFileRequest {
	r.checksumAlgorithm = &checksumAlgorithm
	return r
}

// The source file name. This parameter is usually set by the REST handler. You can only overwrite it when connecting to the trusted port on localhost.
func (r ApiUploadFileRequest) Tmpfilename(tmpfilename string) ApiUploadFileRequest {
	r.tmpfilename = &tmpfilename
	return r
}

func (r ApiUploadFileRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.UploadFileExecute(r)
}

/*
UploadFile uploadFile

Upload templates, ISO images and OVAs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node node
 @param storage storage
 @return ApiUploadFileRequest
*/
func (a *NodesApiService) UploadFile(ctx context.Context, node string, storage string) ApiUploadFileRequest {
	return ApiUploadFileRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		storage: storage,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesApiService) UploadFileExecute(r ApiUploadFileRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesApiService.UploadFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/storage/{storage}/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storage"+"}", url.PathEscape(parameterValueToString(r.storage, "storage")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}
	if r.filename == nil {
		return localVarReturnValue, nil, reportError("filename is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.checksum != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "checksum", r.checksum, "")
	}
	if r.checksumAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "checksum-algorithm", r.checksumAlgorithm, "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "content", r.content, "")
	var filenameLocalVarFormFileName string
	var filenameLocalVarFileName     string
	var filenameLocalVarFileBytes    []byte

	filenameLocalVarFormFileName = "filename"


	filenameLocalVarFile := r.filename

	if filenameLocalVarFile != nil {
		fbs, _ := io.ReadAll(filenameLocalVarFile)

		filenameLocalVarFileBytes = fbs
		filenameLocalVarFileName = filenameLocalVarFile.Name()
		filenameLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: filenameLocalVarFileBytes, fileName: filenameLocalVarFileName, formFileName: filenameLocalVarFormFileName})
	}
	if r.tmpfilename != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tmpfilename", r.tmpfilename, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
