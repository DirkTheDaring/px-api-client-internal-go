/*
ProxMox VE API

ProxMox VE API

API version: 8.0
Contact: baldur@email.de
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pxapiobject

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


type NodesAPI interface {

	/*
	CreateContainer createContainer

	Create or restore a container.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@return ApiCreateContainerRequest
	*/
	CreateContainer(ctx context.Context, node string) ApiCreateContainerRequest

	// CreateContainerExecute executes the request
	//  @return CreateVM200Response
	CreateContainerExecute(r ApiCreateContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	CreateContainerSnapshot createContainerSnapshot

	Snapshot a container.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiCreateContainerSnapshotRequest
	*/
	CreateContainerSnapshot(ctx context.Context, node string, vmid int64) ApiCreateContainerSnapshotRequest

	// CreateContainerSnapshotExecute executes the request
	//  @return TaskStartResponse
	CreateContainerSnapshotExecute(r ApiCreateContainerSnapshotRequest) (*TaskStartResponse, *http.Response, error)

	/*
	CreateNodesSingleStorageSingleContent createNodesSingleStorageSingleContent

	Allocate disk images.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param storage The storage identifier.
	@return ApiCreateNodesSingleStorageSingleContentRequest
	*/
	CreateNodesSingleStorageSingleContent(ctx context.Context, node string, storage string) ApiCreateNodesSingleStorageSingleContentRequest

	// CreateNodesSingleStorageSingleContentExecute executes the request
	//  @return CreateNodesSingleStorageSingleContent200Response
	CreateNodesSingleStorageSingleContentExecute(r ApiCreateNodesSingleStorageSingleContentRequest) (*CreateNodesSingleStorageSingleContent200Response, *http.Response, error)

	/*
	CreateVM createVM

	Create or restore a virtual machine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@return ApiCreateVMRequest
	*/
	CreateVM(ctx context.Context, node string) ApiCreateVMRequest

	// CreateVMExecute executes the request
	//  @return CreateVM200Response
	CreateVMExecute(r ApiCreateVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	CreateVMSnapshot createVMSnapshot

	Snapshot a VM.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiCreateVMSnapshotRequest
	*/
	CreateVMSnapshot(ctx context.Context, node string, vmid int64) ApiCreateVMSnapshotRequest

	// CreateVMSnapshotExecute executes the request
	//  @return TaskStartResponse
	CreateVMSnapshotExecute(r ApiCreateVMSnapshotRequest) (*TaskStartResponse, *http.Response, error)

	/*
	DeleteContainer deleteContainer

	Destroy the container (also delete all uses files).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiDeleteContainerRequest
	*/
	DeleteContainer(ctx context.Context, node string, vmid int64) ApiDeleteContainerRequest

	// DeleteContainerExecute executes the request
	//  @return CreateVM200Response
	DeleteContainerExecute(r ApiDeleteContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	DeleteContainerSnapshot deleteContainerSnapshot

	Delete a LXC snapshot.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@param snapname The name of the snapshot.
	@return ApiDeleteContainerSnapshotRequest
	*/
	DeleteContainerSnapshot(ctx context.Context, node string, vmid int64, snapname string) ApiDeleteContainerSnapshotRequest

	// DeleteContainerSnapshotExecute executes the request
	//  @return TaskStartResponse
	DeleteContainerSnapshotExecute(r ApiDeleteContainerSnapshotRequest) (*TaskStartResponse, *http.Response, error)

	/*
	DeleteVM deleteVM

	Destroy the VM and  all used/owned volumes. Removes any VM specific permissions and firewall rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiDeleteVMRequest
	*/
	DeleteVM(ctx context.Context, node string, vmid int64) ApiDeleteVMRequest

	// DeleteVMExecute executes the request
	//  @return CreateVM200Response
	DeleteVMExecute(r ApiDeleteVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	DeleteVMSnapshot deleteVMSnapshot

	Delete a VM snapshot.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@param snapname The name of the snapshot.
	@return ApiDeleteVMSnapshotRequest
	*/
	DeleteVMSnapshot(ctx context.Context, node string, vmid int64, snapname string) ApiDeleteVMSnapshotRequest

	// DeleteVMSnapshotExecute executes the request
	//  @return TaskStartResponse
	DeleteVMSnapshotExecute(r ApiDeleteVMSnapshotRequest) (*TaskStartResponse, *http.Response, error)

	/*
	GetContainer getContainer

	Directory index

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiGetContainerRequest
	*/
	GetContainer(ctx context.Context, node string, vmid int64) ApiGetContainerRequest

	// GetContainerExecute executes the request
	//  @return GetVM200Response
	GetContainerExecute(r ApiGetContainerRequest) (*GetVM200Response, *http.Response, error)

	/*
	GetContainerConfig getContainerConfig

	Get container configuration.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiGetContainerConfigRequest
	*/
	GetContainerConfig(ctx context.Context, node string, vmid int64) ApiGetContainerConfigRequest

	// GetContainerConfigExecute executes the request
	//  @return GetContainerConfig200Response
	GetContainerConfigExecute(r ApiGetContainerConfigRequest) (*GetContainerConfig200Response, *http.Response, error)

	/*
	GetContainerConfigPending getContainerConfigPending

	Get container configuration, including pending changes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiGetContainerConfigPendingRequest
	*/
	GetContainerConfigPending(ctx context.Context, node string, vmid int64) ApiGetContainerConfigPendingRequest

	// GetContainerConfigPendingExecute executes the request
	//  @return GetContainerConfigPending200Response
	GetContainerConfigPendingExecute(r ApiGetContainerConfigPendingRequest) (*GetContainerConfigPending200Response, *http.Response, error)

	/*
	GetContainerSnapshot getContainerSnapshot

	

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@param snapname The name of the snapshot.
	@return ApiGetContainerSnapshotRequest
	*/
	GetContainerSnapshot(ctx context.Context, node string, vmid int64, snapname string) ApiGetContainerSnapshotRequest

	// GetContainerSnapshotExecute executes the request
	//  @return GetVMSnapshot200Response
	GetContainerSnapshotExecute(r ApiGetContainerSnapshotRequest) (*GetVMSnapshot200Response, *http.Response, error)

	/*
	GetContainerSnapshotConfig getContainerSnapshotConfig

	Get snapshot configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@param snapname The name of the snapshot.
	@return ApiGetContainerSnapshotConfigRequest
	*/
	GetContainerSnapshotConfig(ctx context.Context, node string, vmid int64, snapname string) ApiGetContainerSnapshotConfigRequest

	// GetContainerSnapshotConfigExecute executes the request
	//  @return GetVMSnapshotConfig200Response
	GetContainerSnapshotConfigExecute(r ApiGetContainerSnapshotConfigRequest) (*GetVMSnapshotConfig200Response, *http.Response, error)

	/*
	GetContainerSnapshots getContainerSnapshots

	List all snapshots.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiGetContainerSnapshotsRequest
	*/
	GetContainerSnapshots(ctx context.Context, node string, vmid int64) ApiGetContainerSnapshotsRequest

	// GetContainerSnapshotsExecute executes the request
	//  @return GetContainerSnapshots200Response
	GetContainerSnapshotsExecute(r ApiGetContainerSnapshotsRequest) (*GetContainerSnapshots200Response, *http.Response, error)

	/*
	GetContainerStatus getContainerStatus

	Directory index

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiGetContainerStatusRequest
	*/
	GetContainerStatus(ctx context.Context, node string, vmid int64) ApiGetContainerStatusRequest

	// GetContainerStatusExecute executes the request
	//  @return GetVM200Response
	GetContainerStatusExecute(r ApiGetContainerStatusRequest) (*GetVM200Response, *http.Response, error)

	/*
	GetContainers getContainers

	LXC container index (per node).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@return ApiGetContainersRequest
	*/
	GetContainers(ctx context.Context, node string) ApiGetContainersRequest

	// GetContainersExecute executes the request
	//  @return GetContainers200Response
	GetContainersExecute(r ApiGetContainersRequest) (*GetContainers200Response, *http.Response, error)

	/*
	GetCurrentContainerStatus getCurrentContainerStatus

	Get virtual machine status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiGetCurrentContainerStatusRequest
	*/
	GetCurrentContainerStatus(ctx context.Context, node string, vmid int64) ApiGetCurrentContainerStatusRequest

	// GetCurrentContainerStatusExecute executes the request
	//  @return GetCurrentContainerStatus200Response
	GetCurrentContainerStatusExecute(r ApiGetCurrentContainerStatusRequest) (*GetCurrentContainerStatus200Response, *http.Response, error)

	/*
	GetCurrentVMStatus getCurrentVMStatus

	Get virtual machine status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiGetCurrentVMStatusRequest
	*/
	GetCurrentVMStatus(ctx context.Context, node string, vmid int64) ApiGetCurrentVMStatusRequest

	// GetCurrentVMStatusExecute executes the request
	//  @return GetCurrentVMStatus200Response
	GetCurrentVMStatusExecute(r ApiGetCurrentVMStatusRequest) (*GetCurrentVMStatus200Response, *http.Response, error)

	/*
	GetNodeTask getNodeTask

	

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param upid
	@return ApiGetNodeTaskRequest
	*/
	GetNodeTask(ctx context.Context, node string, upid string) ApiGetNodeTaskRequest

	// GetNodeTaskExecute executes the request
	//  @return GetVMSnapshot200Response
	GetNodeTaskExecute(r ApiGetNodeTaskRequest) (*GetVMSnapshot200Response, *http.Response, error)

	/*
	GetNodeTaskLog getNodeTaskLog

	Read task log.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param upid The task's unique ID.
	@return ApiGetNodeTaskLogRequest
	*/
	GetNodeTaskLog(ctx context.Context, node string, upid string) ApiGetNodeTaskLogRequest

	// GetNodeTaskLogExecute executes the request
	//  @return GetNodeTaskLog200Response
	GetNodeTaskLogExecute(r ApiGetNodeTaskLogRequest) (*GetNodeTaskLog200Response, *http.Response, error)

	/*
	GetNodeTaskStatus getNodeTaskStatus

	Read task status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param upid The task's unique ID.
	@return ApiGetNodeTaskStatusRequest
	*/
	GetNodeTaskStatus(ctx context.Context, node string, upid string) ApiGetNodeTaskStatusRequest

	// GetNodeTaskStatusExecute executes the request
	//  @return GetNodeTaskStatus200Response
	GetNodeTaskStatusExecute(r ApiGetNodeTaskStatusRequest) (*GetNodeTaskStatus200Response, *http.Response, error)

	/*
	GetNodeTasks getNodeTasks

	Read task list for one node (finished tasks).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@return ApiGetNodeTasksRequest
	*/
	GetNodeTasks(ctx context.Context, node string) ApiGetNodeTasksRequest

	// GetNodeTasksExecute executes the request
	//  @return GetNodeTasks200Response
	GetNodeTasksExecute(r ApiGetNodeTasksRequest) (*GetNodeTasks200Response, *http.Response, error)

	/*
	GetStorageContent getStorageContent

	List storage content.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param storage The storage identifier.
	@return ApiGetStorageContentRequest
	*/
	GetStorageContent(ctx context.Context, node string, storage string) ApiGetStorageContentRequest

	// GetStorageContentExecute executes the request
	//  @return GetStorageContent200Response
	GetStorageContentExecute(r ApiGetStorageContentRequest) (*GetStorageContent200Response, *http.Response, error)

	/*
	GetStorages getStorages

	Get status for all datastores.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@return ApiGetStoragesRequest
	*/
	GetStorages(ctx context.Context, node string) ApiGetStoragesRequest

	// GetStoragesExecute executes the request
	//  @return GetStorages200Response
	GetStoragesExecute(r ApiGetStoragesRequest) (*GetStorages200Response, *http.Response, error)

	/*
	GetVM getVM

	Directory index

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiGetVMRequest
	*/
	GetVM(ctx context.Context, node string, vmid int64) ApiGetVMRequest

	// GetVMExecute executes the request
	//  @return GetVM200Response
	GetVMExecute(r ApiGetVMRequest) (*GetVM200Response, *http.Response, error)

	/*
	GetVMConfig getVMConfig

	Get the virtual machine configuration with pending configuration changes applied. Set the 'current' parameter to get the current configuration instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiGetVMConfigRequest
	*/
	GetVMConfig(ctx context.Context, node string, vmid int64) ApiGetVMConfigRequest

	// GetVMConfigExecute executes the request
	//  @return GetVMConfig200Response
	GetVMConfigExecute(r ApiGetVMConfigRequest) (*GetVMConfig200Response, *http.Response, error)

	/*
	GetVMConfigPending getVMConfigPending

	Get the virtual machine configuration with both current and pending values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiGetVMConfigPendingRequest
	*/
	GetVMConfigPending(ctx context.Context, node string, vmid int64) ApiGetVMConfigPendingRequest

	// GetVMConfigPendingExecute executes the request
	//  @return GetVMConfigPending200Response
	GetVMConfigPendingExecute(r ApiGetVMConfigPendingRequest) (*GetVMConfigPending200Response, *http.Response, error)

	/*
	GetVMSnapshot getVMSnapshot

	

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@param snapname The name of the snapshot.
	@return ApiGetVMSnapshotRequest
	*/
	GetVMSnapshot(ctx context.Context, node string, vmid int64, snapname string) ApiGetVMSnapshotRequest

	// GetVMSnapshotExecute executes the request
	//  @return GetVMSnapshot200Response
	GetVMSnapshotExecute(r ApiGetVMSnapshotRequest) (*GetVMSnapshot200Response, *http.Response, error)

	/*
	GetVMSnapshotConfig getVMSnapshotConfig

	Get snapshot configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@param snapname The name of the snapshot.
	@return ApiGetVMSnapshotConfigRequest
	*/
	GetVMSnapshotConfig(ctx context.Context, node string, vmid int64, snapname string) ApiGetVMSnapshotConfigRequest

	// GetVMSnapshotConfigExecute executes the request
	//  @return GetVMSnapshotConfig200Response
	GetVMSnapshotConfigExecute(r ApiGetVMSnapshotConfigRequest) (*GetVMSnapshotConfig200Response, *http.Response, error)

	/*
	GetVMSnapshots getVMSnapshots

	List all snapshots.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiGetVMSnapshotsRequest
	*/
	GetVMSnapshots(ctx context.Context, node string, vmid int64) ApiGetVMSnapshotsRequest

	// GetVMSnapshotsExecute executes the request
	//  @return GetVMSnapshots200Response
	GetVMSnapshotsExecute(r ApiGetVMSnapshotsRequest) (*GetVMSnapshots200Response, *http.Response, error)

	/*
	GetVMs getVMs

	Virtual machine index (per node).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@return ApiGetVMsRequest
	*/
	GetVMs(ctx context.Context, node string) ApiGetVMsRequest

	// GetVMsExecute executes the request
	//  @return GetVMs200Response
	GetVMsExecute(r ApiGetVMsRequest) (*GetVMs200Response, *http.Response, error)

	/*
	RebootContainer rebootContainer

	Reboot the container by shutting it down, and starting it again. Applies pending changes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiRebootContainerRequest
	*/
	RebootContainer(ctx context.Context, node string, vmid int64) ApiRebootContainerRequest

	// RebootContainerExecute executes the request
	//  @return CreateVM200Response
	RebootContainerExecute(r ApiRebootContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	RebootVM rebootVM

	Reboot the VM by shutting it down, and starting it again. Applies pending changes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiRebootVMRequest
	*/
	RebootVM(ctx context.Context, node string, vmid int64) ApiRebootVMRequest

	// RebootVMExecute executes the request
	//  @return CreateVM200Response
	RebootVMExecute(r ApiRebootVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	ResizeContainerDisk resizeContainerDisk

	Resize a container mount point.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiResizeContainerDiskRequest
	*/
	ResizeContainerDisk(ctx context.Context, node string, vmid int64) ApiResizeContainerDiskRequest

	// ResizeContainerDiskExecute executes the request
	//  @return TaskStartResponse
	ResizeContainerDiskExecute(r ApiResizeContainerDiskRequest) (*TaskStartResponse, *http.Response, error)

	/*
	ResizeVMDisk resizeVMDisk

	Extend volume size.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiResizeVMDiskRequest
	*/
	ResizeVMDisk(ctx context.Context, node string, vmid int64) ApiResizeVMDiskRequest

	// ResizeVMDiskExecute executes the request
	//  @return TaskStartResponse
	ResizeVMDiskExecute(r ApiResizeVMDiskRequest) (*TaskStartResponse, *http.Response, error)

	/*
	ResumeContainer resumeContainer

	Resume the container.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiResumeContainerRequest
	*/
	ResumeContainer(ctx context.Context, node string, vmid int64) ApiResumeContainerRequest

	// ResumeContainerExecute executes the request
	//  @return CreateVM200Response
	ResumeContainerExecute(r ApiResumeContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	ResumeVM resumeVM

	Resume virtual machine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiResumeVMRequest
	*/
	ResumeVM(ctx context.Context, node string, vmid int64) ApiResumeVMRequest

	// ResumeVMExecute executes the request
	//  @return CreateVM200Response
	ResumeVMExecute(r ApiResumeVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	RollbackContainerSnapshot rollbackContainerSnapshot

	Rollback LXC state to specified snapshot.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@param snapname The name of the snapshot.
	@return ApiRollbackContainerSnapshotRequest
	*/
	RollbackContainerSnapshot(ctx context.Context, node string, vmid int64, snapname string) ApiRollbackContainerSnapshotRequest

	// RollbackContainerSnapshotExecute executes the request
	//  @return TaskStartResponse
	RollbackContainerSnapshotExecute(r ApiRollbackContainerSnapshotRequest) (*TaskStartResponse, *http.Response, error)

	/*
	RollbackVMSnapshot rollbackVMSnapshot

	Rollback VM state to specified snapshot.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@param snapname The name of the snapshot.
	@return ApiRollbackVMSnapshotRequest
	*/
	RollbackVMSnapshot(ctx context.Context, node string, vmid int64, snapname string) ApiRollbackVMSnapshotRequest

	// RollbackVMSnapshotExecute executes the request
	//  @return TaskStartResponse
	RollbackVMSnapshotExecute(r ApiRollbackVMSnapshotRequest) (*TaskStartResponse, *http.Response, error)

	/*
	ShutdownContainer shutdownContainer

	Shutdown the container. This will trigger a clean shutdown of the container, see lxc-stop(1) for details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiShutdownContainerRequest
	*/
	ShutdownContainer(ctx context.Context, node string, vmid int64) ApiShutdownContainerRequest

	// ShutdownContainerExecute executes the request
	//  @return CreateVM200Response
	ShutdownContainerExecute(r ApiShutdownContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	ShutdownVM shutdownVM

	Shutdown virtual machine. This is similar to pressing the power button on a physical machine.This will send an ACPI event for the guest OS, which should then proceed to a clean shutdown.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiShutdownVMRequest
	*/
	ShutdownVM(ctx context.Context, node string, vmid int64) ApiShutdownVMRequest

	// ShutdownVMExecute executes the request
	//  @return CreateVM200Response
	ShutdownVMExecute(r ApiShutdownVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	StartContainer startContainer

	Start the container.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiStartContainerRequest
	*/
	StartContainer(ctx context.Context, node string, vmid int64) ApiStartContainerRequest

	// StartContainerExecute executes the request
	//  @return CreateVM200Response
	StartContainerExecute(r ApiStartContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	StartVM startVM

	Start virtual machine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiStartVMRequest
	*/
	StartVM(ctx context.Context, node string, vmid int64) ApiStartVMRequest

	// StartVMExecute executes the request
	//  @return CreateVM200Response
	StartVMExecute(r ApiStartVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	StopContainer stopContainer

	Stop the container. This will abruptly stop all processes running in the container.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiStopContainerRequest
	*/
	StopContainer(ctx context.Context, node string, vmid int64) ApiStopContainerRequest

	// StopContainerExecute executes the request
	//  @return CreateVM200Response
	StopContainerExecute(r ApiStopContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	StopNodeTask stopNodeTask

	Stop a task.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param upid
	@return ApiStopNodeTaskRequest
	*/
	StopNodeTask(ctx context.Context, node string, upid string) ApiStopNodeTaskRequest

	// StopNodeTaskExecute executes the request
	//  @return CreateVM200Response
	StopNodeTaskExecute(r ApiStopNodeTaskRequest) (*CreateVM200Response, *http.Response, error)

	/*
	StopVM stopVM

	Stop virtual machine. The qemu process will exit immediately. Thisis akin to pulling the power plug of a running computer and may damage the VM data

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiStopVMRequest
	*/
	StopVM(ctx context.Context, node string, vmid int64) ApiStopVMRequest

	// StopVMExecute executes the request
	//  @return CreateVM200Response
	StopVMExecute(r ApiStopVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	SuspendContainer suspendContainer

	Suspend the container. This is experimental.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiSuspendContainerRequest
	*/
	SuspendContainer(ctx context.Context, node string, vmid int64) ApiSuspendContainerRequest

	// SuspendContainerExecute executes the request
	//  @return CreateVM200Response
	SuspendContainerExecute(r ApiSuspendContainerRequest) (*CreateVM200Response, *http.Response, error)

	/*
	SuspendVM suspendVM

	Suspend virtual machine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiSuspendVMRequest
	*/
	SuspendVM(ctx context.Context, node string, vmid int64) ApiSuspendVMRequest

	// SuspendVMExecute executes the request
	//  @return CreateVM200Response
	SuspendVMExecute(r ApiSuspendVMRequest) (*CreateVM200Response, *http.Response, error)

	/*
	UpdateContainerConfigSync updateContainerConfigSync

	Set container options.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiUpdateContainerConfigSyncRequest
	*/
	UpdateContainerConfigSync(ctx context.Context, node string, vmid int64) ApiUpdateContainerConfigSyncRequest

	// UpdateContainerConfigSyncExecute executes the request
	//  @return CreateVM200Response
	UpdateContainerConfigSyncExecute(r ApiUpdateContainerConfigSyncRequest) (*CreateVM200Response, *http.Response, error)

	/*
	UpdateContainerSnapshotConfig updateContainerSnapshotConfig

	Update snapshot metadata.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@param snapname The name of the snapshot.
	@return ApiUpdateContainerSnapshotConfigRequest
	*/
	UpdateContainerSnapshotConfig(ctx context.Context, node string, vmid int64, snapname string) ApiUpdateContainerSnapshotConfigRequest

	// UpdateContainerSnapshotConfigExecute executes the request
	//  @return CreateVM200Response
	UpdateContainerSnapshotConfigExecute(r ApiUpdateContainerSnapshotConfigRequest) (*CreateVM200Response, *http.Response, error)

	/*
	UpdateVMConfig updateVMConfig

	Set virtual machine options (asynchrounous API).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiUpdateVMConfigRequest
	*/
	UpdateVMConfig(ctx context.Context, node string, vmid int64) ApiUpdateVMConfigRequest

	// UpdateVMConfigExecute executes the request
	//  @return CreateVM200Response
	UpdateVMConfigExecute(r ApiUpdateVMConfigRequest) (*CreateVM200Response, *http.Response, error)

	/*
	UpdateVMConfigSync updateVMConfigSync

	Set virtual machine options (synchrounous API) - You should consider using the POST method instead for any actions involving hotplug or storage allocation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@return ApiUpdateVMConfigSyncRequest
	*/
	UpdateVMConfigSync(ctx context.Context, node string, vmid int64) ApiUpdateVMConfigSyncRequest

	// UpdateVMConfigSyncExecute executes the request
	//  @return CreateVM200Response
	UpdateVMConfigSyncExecute(r ApiUpdateVMConfigSyncRequest) (*CreateVM200Response, *http.Response, error)

	/*
	UpdateVMSnapshotConfig updateVMSnapshotConfig

	Update snapshot metadata.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param vmid The (unique) ID of the VM.
	@param snapname The name of the snapshot.
	@return ApiUpdateVMSnapshotConfigRequest
	*/
	UpdateVMSnapshotConfig(ctx context.Context, node string, vmid int64, snapname string) ApiUpdateVMSnapshotConfigRequest

	// UpdateVMSnapshotConfigExecute executes the request
	//  @return CreateVM200Response
	UpdateVMSnapshotConfigExecute(r ApiUpdateVMSnapshotConfigRequest) (*CreateVM200Response, *http.Response, error)

	/*
	UploadFile uploadFile

	Upload templates and ISO images.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param node The cluster node name.
	@param storage The storage identifier.
	@return ApiUploadFileRequest
	*/
	UploadFile(ctx context.Context, node string, storage string) ApiUploadFileRequest

	// UploadFileExecute executes the request
	//  @return CreateVM200Response
	UploadFileExecute(r ApiUploadFileRequest) (*CreateVM200Response, *http.Response, error)
}

// NodesAPIService NodesAPI service
type NodesAPIService service

type ApiCreateContainerRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	createContainerRequest *CreateContainerRequest
}

func (r ApiCreateContainerRequest) CreateContainerRequest(createContainerRequest CreateContainerRequest) ApiCreateContainerRequest {
	r.createContainerRequest = &createContainerRequest
	return r
}

func (r ApiCreateContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.CreateContainerExecute(r)
}

/*
CreateContainer createContainer

Create or restore a container.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @return ApiCreateContainerRequest
*/
func (a *NodesAPIService) CreateContainer(ctx context.Context, node string) ApiCreateContainerRequest {
	return ApiCreateContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) CreateContainerExecute(r ApiCreateContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.CreateContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createContainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateContainerSnapshotRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	createContainerSnapshotRequest *CreateContainerSnapshotRequest
}

func (r ApiCreateContainerSnapshotRequest) CreateContainerSnapshotRequest(createContainerSnapshotRequest CreateContainerSnapshotRequest) ApiCreateContainerSnapshotRequest {
	r.createContainerSnapshotRequest = &createContainerSnapshotRequest
	return r
}

func (r ApiCreateContainerSnapshotRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.CreateContainerSnapshotExecute(r)
}

/*
CreateContainerSnapshot createContainerSnapshot

Snapshot a container.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiCreateContainerSnapshotRequest
*/
func (a *NodesAPIService) CreateContainerSnapshot(ctx context.Context, node string, vmid int64) ApiCreateContainerSnapshotRequest {
	return ApiCreateContainerSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesAPIService) CreateContainerSnapshotExecute(r ApiCreateContainerSnapshotRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.CreateContainerSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createContainerSnapshotRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNodesSingleStorageSingleContentRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	storage string
	createNodesSingleStorageSingleContentRequest *CreateNodesSingleStorageSingleContentRequest
}

func (r ApiCreateNodesSingleStorageSingleContentRequest) CreateNodesSingleStorageSingleContentRequest(createNodesSingleStorageSingleContentRequest CreateNodesSingleStorageSingleContentRequest) ApiCreateNodesSingleStorageSingleContentRequest {
	r.createNodesSingleStorageSingleContentRequest = &createNodesSingleStorageSingleContentRequest
	return r
}

func (r ApiCreateNodesSingleStorageSingleContentRequest) Execute() (*CreateNodesSingleStorageSingleContent200Response, *http.Response, error) {
	return r.ApiService.CreateNodesSingleStorageSingleContentExecute(r)
}

/*
CreateNodesSingleStorageSingleContent createNodesSingleStorageSingleContent

Allocate disk images.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param storage The storage identifier.
 @return ApiCreateNodesSingleStorageSingleContentRequest
*/
func (a *NodesAPIService) CreateNodesSingleStorageSingleContent(ctx context.Context, node string, storage string) ApiCreateNodesSingleStorageSingleContentRequest {
	return ApiCreateNodesSingleStorageSingleContentRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		storage: storage,
	}
}

// Execute executes the request
//  @return CreateNodesSingleStorageSingleContent200Response
func (a *NodesAPIService) CreateNodesSingleStorageSingleContentExecute(r ApiCreateNodesSingleStorageSingleContentRequest) (*CreateNodesSingleStorageSingleContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateNodesSingleStorageSingleContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.CreateNodesSingleStorageSingleContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/storage/{storage}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storage"+"}", url.PathEscape(parameterValueToString(r.storage, "storage")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createNodesSingleStorageSingleContentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVMRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	createVMRequest *CreateVMRequest
}

func (r ApiCreateVMRequest) CreateVMRequest(createVMRequest CreateVMRequest) ApiCreateVMRequest {
	r.createVMRequest = &createVMRequest
	return r
}

func (r ApiCreateVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.CreateVMExecute(r)
}

/*
CreateVM createVM

Create or restore a virtual machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @return ApiCreateVMRequest
*/
func (a *NodesAPIService) CreateVM(ctx context.Context, node string) ApiCreateVMRequest {
	return ApiCreateVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) CreateVMExecute(r ApiCreateVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.CreateVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVMSnapshotRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	createVMSnapshotRequest *CreateVMSnapshotRequest
}

func (r ApiCreateVMSnapshotRequest) CreateVMSnapshotRequest(createVMSnapshotRequest CreateVMSnapshotRequest) ApiCreateVMSnapshotRequest {
	r.createVMSnapshotRequest = &createVMSnapshotRequest
	return r
}

func (r ApiCreateVMSnapshotRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.CreateVMSnapshotExecute(r)
}

/*
CreateVMSnapshot createVMSnapshot

Snapshot a VM.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiCreateVMSnapshotRequest
*/
func (a *NodesAPIService) CreateVMSnapshot(ctx context.Context, node string, vmid int64) ApiCreateVMSnapshotRequest {
	return ApiCreateVMSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesAPIService) CreateVMSnapshotExecute(r ApiCreateVMSnapshotRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.CreateVMSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVMSnapshotRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteContainerRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	destroyUnreferencedDisks *bool
	force *bool
	purge *bool
}

// If set, destroy additionally all disks with the VMID from all enabled storages which are not referenced in the config.
func (r ApiDeleteContainerRequest) DestroyUnreferencedDisks(destroyUnreferencedDisks bool) ApiDeleteContainerRequest {
	r.destroyUnreferencedDisks = &destroyUnreferencedDisks
	return r
}

// Force destroy, even if running.
func (r ApiDeleteContainerRequest) Force(force bool) ApiDeleteContainerRequest {
	r.force = &force
	return r
}

// Remove container from all related configurations. For example, backup jobs, replication jobs or HA. Related ACLs and Firewall entries will *always* be removed.
func (r ApiDeleteContainerRequest) Purge(purge bool) ApiDeleteContainerRequest {
	r.purge = &purge
	return r
}

func (r ApiDeleteContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.DeleteContainerExecute(r)
}

/*
DeleteContainer deleteContainer

Destroy the container (also delete all uses files).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiDeleteContainerRequest
*/
func (a *NodesAPIService) DeleteContainer(ctx context.Context, node string, vmid int64) ApiDeleteContainerRequest {
	return ApiDeleteContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) DeleteContainerExecute(r ApiDeleteContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.DeleteContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	if r.destroyUnreferencedDisks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destroy-unreferenced-disks", r.destroyUnreferencedDisks, "")
	}
	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.purge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge", r.purge, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteContainerSnapshotRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	snapname string
	force *bool
}

// For removal from config file, even if removing disk snapshots fails.
func (r ApiDeleteContainerSnapshotRequest) Force(force bool) ApiDeleteContainerSnapshotRequest {
	r.force = &force
	return r
}

func (r ApiDeleteContainerSnapshotRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.DeleteContainerSnapshotExecute(r)
}

/*
DeleteContainerSnapshot deleteContainerSnapshot

Delete a LXC snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @param snapname The name of the snapshot.
 @return ApiDeleteContainerSnapshotRequest
*/
func (a *NodesAPIService) DeleteContainerSnapshot(ctx context.Context, node string, vmid int64, snapname string) ApiDeleteContainerSnapshotRequest {
	return ApiDeleteContainerSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
		snapname: snapname,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesAPIService) DeleteContainerSnapshotExecute(r ApiDeleteContainerSnapshotRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.DeleteContainerSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot/{snapname}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVMRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	destroyUnreferencedDisks *bool
	purge *bool
	skiplock *bool
}

// If set, destroy additionally all disks not referenced in the config but with a matching VMID from all enabled storages.
func (r ApiDeleteVMRequest) DestroyUnreferencedDisks(destroyUnreferencedDisks bool) ApiDeleteVMRequest {
	r.destroyUnreferencedDisks = &destroyUnreferencedDisks
	return r
}

// Remove VMID from configurations, like backup &amp; replication jobs and HA.
func (r ApiDeleteVMRequest) Purge(purge bool) ApiDeleteVMRequest {
	r.purge = &purge
	return r
}

// Ignore locks - only root is allowed to use this option.
func (r ApiDeleteVMRequest) Skiplock(skiplock bool) ApiDeleteVMRequest {
	r.skiplock = &skiplock
	return r
}

func (r ApiDeleteVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.DeleteVMExecute(r)
}

/*
DeleteVM deleteVM

Destroy the VM and  all used/owned volumes. Removes any VM specific permissions and firewall rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiDeleteVMRequest
*/
func (a *NodesAPIService) DeleteVM(ctx context.Context, node string, vmid int64) ApiDeleteVMRequest {
	return ApiDeleteVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) DeleteVMExecute(r ApiDeleteVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.DeleteVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	if r.destroyUnreferencedDisks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destroy-unreferenced-disks", r.destroyUnreferencedDisks, "")
	}
	if r.purge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge", r.purge, "")
	}
	if r.skiplock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skiplock", r.skiplock, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVMSnapshotRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	snapname string
	force *bool
}

// For removal from config file, even if removing disk snapshots fails.
func (r ApiDeleteVMSnapshotRequest) Force(force bool) ApiDeleteVMSnapshotRequest {
	r.force = &force
	return r
}

func (r ApiDeleteVMSnapshotRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.DeleteVMSnapshotExecute(r)
}

/*
DeleteVMSnapshot deleteVMSnapshot

Delete a VM snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @param snapname The name of the snapshot.
 @return ApiDeleteVMSnapshotRequest
*/
func (a *NodesAPIService) DeleteVMSnapshot(ctx context.Context, node string, vmid int64, snapname string) ApiDeleteVMSnapshotRequest {
	return ApiDeleteVMSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
		snapname: snapname,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesAPIService) DeleteVMSnapshotExecute(r ApiDeleteVMSnapshotRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.DeleteVMSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot/{snapname}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
}

func (r ApiGetContainerRequest) Execute() (*GetVM200Response, *http.Response, error) {
	return r.ApiService.GetContainerExecute(r)
}

/*
GetContainer getContainer

Directory index

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiGetContainerRequest
*/
func (a *NodesAPIService) GetContainer(ctx context.Context, node string, vmid int64) ApiGetContainerRequest {
	return ApiGetContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVM200Response
func (a *NodesAPIService) GetContainerExecute(r ApiGetContainerRequest) (*GetVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerConfigRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	current *bool
	snapshot *string
}

// Get current values (instead of pending values).
func (r ApiGetContainerConfigRequest) Current(current bool) ApiGetContainerConfigRequest {
	r.current = &current
	return r
}

// Fetch config values from given snapshot.
func (r ApiGetContainerConfigRequest) Snapshot(snapshot string) ApiGetContainerConfigRequest {
	r.snapshot = &snapshot
	return r
}

func (r ApiGetContainerConfigRequest) Execute() (*GetContainerConfig200Response, *http.Response, error) {
	return r.ApiService.GetContainerConfigExecute(r)
}

/*
GetContainerConfig getContainerConfig

Get container configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiGetContainerConfigRequest
*/
func (a *NodesAPIService) GetContainerConfig(ctx context.Context, node string, vmid int64) ApiGetContainerConfigRequest {
	return ApiGetContainerConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetContainerConfig200Response
func (a *NodesAPIService) GetContainerConfigExecute(r ApiGetContainerConfigRequest) (*GetContainerConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContainerConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetContainerConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "")
	}
	if r.snapshot != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshot", r.snapshot, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerConfigPendingRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
}

func (r ApiGetContainerConfigPendingRequest) Execute() (*GetContainerConfigPending200Response, *http.Response, error) {
	return r.ApiService.GetContainerConfigPendingExecute(r)
}

/*
GetContainerConfigPending getContainerConfigPending

Get container configuration, including pending changes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiGetContainerConfigPendingRequest
*/
func (a *NodesAPIService) GetContainerConfigPending(ctx context.Context, node string, vmid int64) ApiGetContainerConfigPendingRequest {
	return ApiGetContainerConfigPendingRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetContainerConfigPending200Response
func (a *NodesAPIService) GetContainerConfigPendingExecute(r ApiGetContainerConfigPendingRequest) (*GetContainerConfigPending200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContainerConfigPending200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetContainerConfigPending")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/pending"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerSnapshotRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	snapname string
}

func (r ApiGetContainerSnapshotRequest) Execute() (*GetVMSnapshot200Response, *http.Response, error) {
	return r.ApiService.GetContainerSnapshotExecute(r)
}

/*
GetContainerSnapshot getContainerSnapshot



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @param snapname The name of the snapshot.
 @return ApiGetContainerSnapshotRequest
*/
func (a *NodesAPIService) GetContainerSnapshot(ctx context.Context, node string, vmid int64, snapname string) ApiGetContainerSnapshotRequest {
	return ApiGetContainerSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
		snapname: snapname,
	}
}

// Execute executes the request
//  @return GetVMSnapshot200Response
func (a *NodesAPIService) GetContainerSnapshotExecute(r ApiGetContainerSnapshotRequest) (*GetVMSnapshot200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMSnapshot200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetContainerSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot/{snapname}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerSnapshotConfigRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	snapname string
}

func (r ApiGetContainerSnapshotConfigRequest) Execute() (*GetVMSnapshotConfig200Response, *http.Response, error) {
	return r.ApiService.GetContainerSnapshotConfigExecute(r)
}

/*
GetContainerSnapshotConfig getContainerSnapshotConfig

Get snapshot configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @param snapname The name of the snapshot.
 @return ApiGetContainerSnapshotConfigRequest
*/
func (a *NodesAPIService) GetContainerSnapshotConfig(ctx context.Context, node string, vmid int64, snapname string) ApiGetContainerSnapshotConfigRequest {
	return ApiGetContainerSnapshotConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
		snapname: snapname,
	}
}

// Execute executes the request
//  @return GetVMSnapshotConfig200Response
func (a *NodesAPIService) GetContainerSnapshotConfigExecute(r ApiGetContainerSnapshotConfigRequest) (*GetVMSnapshotConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMSnapshotConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetContainerSnapshotConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot/{snapname}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerSnapshotsRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
}

func (r ApiGetContainerSnapshotsRequest) Execute() (*GetContainerSnapshots200Response, *http.Response, error) {
	return r.ApiService.GetContainerSnapshotsExecute(r)
}

/*
GetContainerSnapshots getContainerSnapshots

List all snapshots.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiGetContainerSnapshotsRequest
*/
func (a *NodesAPIService) GetContainerSnapshots(ctx context.Context, node string, vmid int64) ApiGetContainerSnapshotsRequest {
	return ApiGetContainerSnapshotsRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetContainerSnapshots200Response
func (a *NodesAPIService) GetContainerSnapshotsExecute(r ApiGetContainerSnapshotsRequest) (*GetContainerSnapshots200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContainerSnapshots200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetContainerSnapshots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerStatusRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
}

func (r ApiGetContainerStatusRequest) Execute() (*GetVM200Response, *http.Response, error) {
	return r.ApiService.GetContainerStatusExecute(r)
}

/*
GetContainerStatus getContainerStatus

Directory index

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiGetContainerStatusRequest
*/
func (a *NodesAPIService) GetContainerStatus(ctx context.Context, node string, vmid int64) ApiGetContainerStatusRequest {
	return ApiGetContainerStatusRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVM200Response
func (a *NodesAPIService) GetContainerStatusExecute(r ApiGetContainerStatusRequest) (*GetVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetContainerStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainersRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
}

func (r ApiGetContainersRequest) Execute() (*GetContainers200Response, *http.Response, error) {
	return r.ApiService.GetContainersExecute(r)
}

/*
GetContainers getContainers

LXC container index (per node).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @return ApiGetContainersRequest
*/
func (a *NodesAPIService) GetContainers(ctx context.Context, node string) ApiGetContainersRequest {
	return ApiGetContainersRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
	}
}

// Execute executes the request
//  @return GetContainers200Response
func (a *NodesAPIService) GetContainersExecute(r ApiGetContainersRequest) (*GetContainers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContainers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetContainers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrentContainerStatusRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
}

func (r ApiGetCurrentContainerStatusRequest) Execute() (*GetCurrentContainerStatus200Response, *http.Response, error) {
	return r.ApiService.GetCurrentContainerStatusExecute(r)
}

/*
GetCurrentContainerStatus getCurrentContainerStatus

Get virtual machine status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiGetCurrentContainerStatusRequest
*/
func (a *NodesAPIService) GetCurrentContainerStatus(ctx context.Context, node string, vmid int64) ApiGetCurrentContainerStatusRequest {
	return ApiGetCurrentContainerStatusRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetCurrentContainerStatus200Response
func (a *NodesAPIService) GetCurrentContainerStatusExecute(r ApiGetCurrentContainerStatusRequest) (*GetCurrentContainerStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCurrentContainerStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetCurrentContainerStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/current"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrentVMStatusRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
}

func (r ApiGetCurrentVMStatusRequest) Execute() (*GetCurrentVMStatus200Response, *http.Response, error) {
	return r.ApiService.GetCurrentVMStatusExecute(r)
}

/*
GetCurrentVMStatus getCurrentVMStatus

Get virtual machine status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiGetCurrentVMStatusRequest
*/
func (a *NodesAPIService) GetCurrentVMStatus(ctx context.Context, node string, vmid int64) ApiGetCurrentVMStatusRequest {
	return ApiGetCurrentVMStatusRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetCurrentVMStatus200Response
func (a *NodesAPIService) GetCurrentVMStatusExecute(r ApiGetCurrentVMStatusRequest) (*GetCurrentVMStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCurrentVMStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetCurrentVMStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/current"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeTaskRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	upid string
}

func (r ApiGetNodeTaskRequest) Execute() (*GetVMSnapshot200Response, *http.Response, error) {
	return r.ApiService.GetNodeTaskExecute(r)
}

/*
GetNodeTask getNodeTask



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param upid
 @return ApiGetNodeTaskRequest
*/
func (a *NodesAPIService) GetNodeTask(ctx context.Context, node string, upid string) ApiGetNodeTaskRequest {
	return ApiGetNodeTaskRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		upid: upid,
	}
}

// Execute executes the request
//  @return GetVMSnapshot200Response
func (a *NodesAPIService) GetNodeTaskExecute(r ApiGetNodeTaskRequest) (*GetVMSnapshot200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMSnapshot200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetNodeTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/tasks/{upid}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upid"+"}", url.PathEscape(parameterValueToString(r.upid, "upid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeTaskLogRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	upid string
	download *bool
	limit *int64
	start *int64
}

// Whether the tasklog file should be downloaded. This parameter can&#39;t be used in conjunction with other parameters
func (r ApiGetNodeTaskLogRequest) Download(download bool) ApiGetNodeTaskLogRequest {
	r.download = &download
	return r
}

// The amount of lines to read from the tasklog.
func (r ApiGetNodeTaskLogRequest) Limit(limit int64) ApiGetNodeTaskLogRequest {
	r.limit = &limit
	return r
}

// Start at this line when reading the tasklog
func (r ApiGetNodeTaskLogRequest) Start(start int64) ApiGetNodeTaskLogRequest {
	r.start = &start
	return r
}

func (r ApiGetNodeTaskLogRequest) Execute() (*GetNodeTaskLog200Response, *http.Response, error) {
	return r.ApiService.GetNodeTaskLogExecute(r)
}

/*
GetNodeTaskLog getNodeTaskLog

Read task log.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param upid The task's unique ID.
 @return ApiGetNodeTaskLogRequest
*/
func (a *NodesAPIService) GetNodeTaskLog(ctx context.Context, node string, upid string) ApiGetNodeTaskLogRequest {
	return ApiGetNodeTaskLogRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		upid: upid,
	}
}

// Execute executes the request
//  @return GetNodeTaskLog200Response
func (a *NodesAPIService) GetNodeTaskLogExecute(r ApiGetNodeTaskLogRequest) (*GetNodeTaskLog200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeTaskLog200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetNodeTaskLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/tasks/{upid}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upid"+"}", url.PathEscape(parameterValueToString(r.upid, "upid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.download != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "download", r.download, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeTaskStatusRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	upid string
}

func (r ApiGetNodeTaskStatusRequest) Execute() (*GetNodeTaskStatus200Response, *http.Response, error) {
	return r.ApiService.GetNodeTaskStatusExecute(r)
}

/*
GetNodeTaskStatus getNodeTaskStatus

Read task status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param upid The task's unique ID.
 @return ApiGetNodeTaskStatusRequest
*/
func (a *NodesAPIService) GetNodeTaskStatus(ctx context.Context, node string, upid string) ApiGetNodeTaskStatusRequest {
	return ApiGetNodeTaskStatusRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		upid: upid,
	}
}

// Execute executes the request
//  @return GetNodeTaskStatus200Response
func (a *NodesAPIService) GetNodeTaskStatusExecute(r ApiGetNodeTaskStatusRequest) (*GetNodeTaskStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeTaskStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetNodeTaskStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/tasks/{upid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upid"+"}", url.PathEscape(parameterValueToString(r.upid, "upid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeTasksRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	errors *bool
	limit *int64
	since *int64
	source *string
	start *int64
	statusfilter *string
	typefilter *string
	until *int64
	userfilter *string
	vmid *int64
}

// Only list tasks with a status of ERROR.
func (r ApiGetNodeTasksRequest) Errors(errors bool) ApiGetNodeTasksRequest {
	r.errors = &errors
	return r
}

// Only list this amount of tasks.
func (r ApiGetNodeTasksRequest) Limit(limit int64) ApiGetNodeTasksRequest {
	r.limit = &limit
	return r
}

// Only list tasks since this UNIX epoch.
func (r ApiGetNodeTasksRequest) Since(since int64) ApiGetNodeTasksRequest {
	r.since = &since
	return r
}

// List archived, active or all tasks.
func (r ApiGetNodeTasksRequest) Source(source string) ApiGetNodeTasksRequest {
	r.source = &source
	return r
}

// List tasks beginning from this offset.
func (r ApiGetNodeTasksRequest) Start(start int64) ApiGetNodeTasksRequest {
	r.start = &start
	return r
}

// List of Task States that should be returned.
func (r ApiGetNodeTasksRequest) Statusfilter(statusfilter string) ApiGetNodeTasksRequest {
	r.statusfilter = &statusfilter
	return r
}

// Only list tasks of this type (e.g., vzstart, vzdump).
func (r ApiGetNodeTasksRequest) Typefilter(typefilter string) ApiGetNodeTasksRequest {
	r.typefilter = &typefilter
	return r
}

// Only list tasks until this UNIX epoch.
func (r ApiGetNodeTasksRequest) Until(until int64) ApiGetNodeTasksRequest {
	r.until = &until
	return r
}

// Only list tasks from this user.
func (r ApiGetNodeTasksRequest) Userfilter(userfilter string) ApiGetNodeTasksRequest {
	r.userfilter = &userfilter
	return r
}

// Only list tasks for this VM.
func (r ApiGetNodeTasksRequest) Vmid(vmid int64) ApiGetNodeTasksRequest {
	r.vmid = &vmid
	return r
}

func (r ApiGetNodeTasksRequest) Execute() (*GetNodeTasks200Response, *http.Response, error) {
	return r.ApiService.GetNodeTasksExecute(r)
}

/*
GetNodeTasks getNodeTasks

Read task list for one node (finished tasks).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @return ApiGetNodeTasksRequest
*/
func (a *NodesAPIService) GetNodeTasks(ctx context.Context, node string) ApiGetNodeTasksRequest {
	return ApiGetNodeTasksRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
	}
}

// Execute executes the request
//  @return GetNodeTasks200Response
func (a *NodesAPIService) GetNodeTasksExecute(r ApiGetNodeTasksRequest) (*GetNodeTasks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeTasks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetNodeTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.errors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "errors", r.errors, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "")
	}
	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.statusfilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statusfilter", r.statusfilter, "")
	}
	if r.typefilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typefilter", r.typefilter, "")
	}
	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "")
	}
	if r.userfilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userfilter", r.userfilter, "")
	}
	if r.vmid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vmid", r.vmid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStorageContentRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	storage string
	content *string
	vmid *int64
}

// Only list content of this type.
func (r ApiGetStorageContentRequest) Content(content string) ApiGetStorageContentRequest {
	r.content = &content
	return r
}

// Only list images for this VM
func (r ApiGetStorageContentRequest) Vmid(vmid int64) ApiGetStorageContentRequest {
	r.vmid = &vmid
	return r
}

func (r ApiGetStorageContentRequest) Execute() (*GetStorageContent200Response, *http.Response, error) {
	return r.ApiService.GetStorageContentExecute(r)
}

/*
GetStorageContent getStorageContent

List storage content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param storage The storage identifier.
 @return ApiGetStorageContentRequest
*/
func (a *NodesAPIService) GetStorageContent(ctx context.Context, node string, storage string) ApiGetStorageContentRequest {
	return ApiGetStorageContentRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		storage: storage,
	}
}

// Execute executes the request
//  @return GetStorageContent200Response
func (a *NodesAPIService) GetStorageContentExecute(r ApiGetStorageContentRequest) (*GetStorageContent200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetStorageContent200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetStorageContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/storage/{storage}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storage"+"}", url.PathEscape(parameterValueToString(r.storage, "storage")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.content != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "content", r.content, "")
	}
	if r.vmid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vmid", r.vmid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStoragesRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	content *string
	enabled *bool
	format *bool
	storage *string
	target *string
}

// Only list stores which support this content type.
func (r ApiGetStoragesRequest) Content(content string) ApiGetStoragesRequest {
	r.content = &content
	return r
}

// Only list stores which are enabled (not disabled in config).
func (r ApiGetStoragesRequest) Enabled(enabled bool) ApiGetStoragesRequest {
	r.enabled = &enabled
	return r
}

// Include information about formats
func (r ApiGetStoragesRequest) Format(format bool) ApiGetStoragesRequest {
	r.format = &format
	return r
}

// Only list status for  specified storage
func (r ApiGetStoragesRequest) Storage(storage string) ApiGetStoragesRequest {
	r.storage = &storage
	return r
}

// If target is different to &#39;node&#39;, we only lists shared storages which content is accessible on this &#39;node&#39; and the specified &#39;target&#39; node.
func (r ApiGetStoragesRequest) Target(target string) ApiGetStoragesRequest {
	r.target = &target
	return r
}

func (r ApiGetStoragesRequest) Execute() (*GetStorages200Response, *http.Response, error) {
	return r.ApiService.GetStoragesExecute(r)
}

/*
GetStorages getStorages

Get status for all datastores.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @return ApiGetStoragesRequest
*/
func (a *NodesAPIService) GetStorages(ctx context.Context, node string) ApiGetStoragesRequest {
	return ApiGetStoragesRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
	}
}

// Execute executes the request
//  @return GetStorages200Response
func (a *NodesAPIService) GetStoragesExecute(r ApiGetStoragesRequest) (*GetStorages200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetStorages200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetStorages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/storage"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.content != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "content", r.content, "")
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.storage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storage", r.storage, "")
	}
	if r.target != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target", r.target, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
}

func (r ApiGetVMRequest) Execute() (*GetVM200Response, *http.Response, error) {
	return r.ApiService.GetVMExecute(r)
}

/*
GetVM getVM

Directory index

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiGetVMRequest
*/
func (a *NodesAPIService) GetVM(ctx context.Context, node string, vmid int64) ApiGetVMRequest {
	return ApiGetVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVM200Response
func (a *NodesAPIService) GetVMExecute(r ApiGetVMRequest) (*GetVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMConfigRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	current *bool
	snapshot *string
}

// Get current values (instead of pending values).
func (r ApiGetVMConfigRequest) Current(current bool) ApiGetVMConfigRequest {
	r.current = &current
	return r
}

// Fetch config values from given snapshot.
func (r ApiGetVMConfigRequest) Snapshot(snapshot string) ApiGetVMConfigRequest {
	r.snapshot = &snapshot
	return r
}

func (r ApiGetVMConfigRequest) Execute() (*GetVMConfig200Response, *http.Response, error) {
	return r.ApiService.GetVMConfigExecute(r)
}

/*
GetVMConfig getVMConfig

Get the virtual machine configuration with pending configuration changes applied. Set the 'current' parameter to get the current configuration instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiGetVMConfigRequest
*/
func (a *NodesAPIService) GetVMConfig(ctx context.Context, node string, vmid int64) ApiGetVMConfigRequest {
	return ApiGetVMConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVMConfig200Response
func (a *NodesAPIService) GetVMConfigExecute(r ApiGetVMConfigRequest) (*GetVMConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetVMConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "")
	}
	if r.snapshot != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshot", r.snapshot, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMConfigPendingRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
}

func (r ApiGetVMConfigPendingRequest) Execute() (*GetVMConfigPending200Response, *http.Response, error) {
	return r.ApiService.GetVMConfigPendingExecute(r)
}

/*
GetVMConfigPending getVMConfigPending

Get the virtual machine configuration with both current and pending values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiGetVMConfigPendingRequest
*/
func (a *NodesAPIService) GetVMConfigPending(ctx context.Context, node string, vmid int64) ApiGetVMConfigPendingRequest {
	return ApiGetVMConfigPendingRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVMConfigPending200Response
func (a *NodesAPIService) GetVMConfigPendingExecute(r ApiGetVMConfigPendingRequest) (*GetVMConfigPending200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMConfigPending200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetVMConfigPending")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/pending"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMSnapshotRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	snapname string
}

func (r ApiGetVMSnapshotRequest) Execute() (*GetVMSnapshot200Response, *http.Response, error) {
	return r.ApiService.GetVMSnapshotExecute(r)
}

/*
GetVMSnapshot getVMSnapshot



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @param snapname The name of the snapshot.
 @return ApiGetVMSnapshotRequest
*/
func (a *NodesAPIService) GetVMSnapshot(ctx context.Context, node string, vmid int64, snapname string) ApiGetVMSnapshotRequest {
	return ApiGetVMSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
		snapname: snapname,
	}
}

// Execute executes the request
//  @return GetVMSnapshot200Response
func (a *NodesAPIService) GetVMSnapshotExecute(r ApiGetVMSnapshotRequest) (*GetVMSnapshot200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMSnapshot200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetVMSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot/{snapname}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMSnapshotConfigRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	snapname string
}

func (r ApiGetVMSnapshotConfigRequest) Execute() (*GetVMSnapshotConfig200Response, *http.Response, error) {
	return r.ApiService.GetVMSnapshotConfigExecute(r)
}

/*
GetVMSnapshotConfig getVMSnapshotConfig

Get snapshot configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @param snapname The name of the snapshot.
 @return ApiGetVMSnapshotConfigRequest
*/
func (a *NodesAPIService) GetVMSnapshotConfig(ctx context.Context, node string, vmid int64, snapname string) ApiGetVMSnapshotConfigRequest {
	return ApiGetVMSnapshotConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
		snapname: snapname,
	}
}

// Execute executes the request
//  @return GetVMSnapshotConfig200Response
func (a *NodesAPIService) GetVMSnapshotConfigExecute(r ApiGetVMSnapshotConfigRequest) (*GetVMSnapshotConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMSnapshotConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetVMSnapshotConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot/{snapname}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMSnapshotsRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
}

func (r ApiGetVMSnapshotsRequest) Execute() (*GetVMSnapshots200Response, *http.Response, error) {
	return r.ApiService.GetVMSnapshotsExecute(r)
}

/*
GetVMSnapshots getVMSnapshots

List all snapshots.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiGetVMSnapshotsRequest
*/
func (a *NodesAPIService) GetVMSnapshots(ctx context.Context, node string, vmid int64) ApiGetVMSnapshotsRequest {
	return ApiGetVMSnapshotsRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return GetVMSnapshots200Response
func (a *NodesAPIService) GetVMSnapshotsExecute(r ApiGetVMSnapshotsRequest) (*GetVMSnapshots200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMSnapshots200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetVMSnapshots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVMsRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	full *bool
}

// Determine the full status of active VMs.
func (r ApiGetVMsRequest) Full(full bool) ApiGetVMsRequest {
	r.full = &full
	return r
}

func (r ApiGetVMsRequest) Execute() (*GetVMs200Response, *http.Response, error) {
	return r.ApiService.GetVMsExecute(r)
}

/*
GetVMs getVMs

Virtual machine index (per node).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @return ApiGetVMsRequest
*/
func (a *NodesAPIService) GetVMs(ctx context.Context, node string) ApiGetVMsRequest {
	return ApiGetVMsRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
	}
}

// Execute executes the request
//  @return GetVMs200Response
func (a *NodesAPIService) GetVMsExecute(r ApiGetVMsRequest) (*GetVMs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVMs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.GetVMs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.full != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "full", r.full, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRebootContainerRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	rebootContainerRequest *RebootContainerRequest
}

func (r ApiRebootContainerRequest) RebootContainerRequest(rebootContainerRequest RebootContainerRequest) ApiRebootContainerRequest {
	r.rebootContainerRequest = &rebootContainerRequest
	return r
}

func (r ApiRebootContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.RebootContainerExecute(r)
}

/*
RebootContainer rebootContainer

Reboot the container by shutting it down, and starting it again. Applies pending changes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiRebootContainerRequest
*/
func (a *NodesAPIService) RebootContainer(ctx context.Context, node string, vmid int64) ApiRebootContainerRequest {
	return ApiRebootContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) RebootContainerExecute(r ApiRebootContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.RebootContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/reboot"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rebootContainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRebootVMRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	rebootVMRequest *RebootVMRequest
}

func (r ApiRebootVMRequest) RebootVMRequest(rebootVMRequest RebootVMRequest) ApiRebootVMRequest {
	r.rebootVMRequest = &rebootVMRequest
	return r
}

func (r ApiRebootVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.RebootVMExecute(r)
}

/*
RebootVM rebootVM

Reboot the VM by shutting it down, and starting it again. Applies pending changes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiRebootVMRequest
*/
func (a *NodesAPIService) RebootVM(ctx context.Context, node string, vmid int64) ApiRebootVMRequest {
	return ApiRebootVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) RebootVMExecute(r ApiRebootVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.RebootVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/reboot"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rebootVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResizeContainerDiskRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	resizeContainerDiskRequest *ResizeContainerDiskRequest
}

func (r ApiResizeContainerDiskRequest) ResizeContainerDiskRequest(resizeContainerDiskRequest ResizeContainerDiskRequest) ApiResizeContainerDiskRequest {
	r.resizeContainerDiskRequest = &resizeContainerDiskRequest
	return r
}

func (r ApiResizeContainerDiskRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.ResizeContainerDiskExecute(r)
}

/*
ResizeContainerDisk resizeContainerDisk

Resize a container mount point.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiResizeContainerDiskRequest
*/
func (a *NodesAPIService) ResizeContainerDisk(ctx context.Context, node string, vmid int64) ApiResizeContainerDiskRequest {
	return ApiResizeContainerDiskRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesAPIService) ResizeContainerDiskExecute(r ApiResizeContainerDiskRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.ResizeContainerDisk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/resize"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resizeContainerDiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResizeVMDiskRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	resizeVMDiskRequest *ResizeVMDiskRequest
}

func (r ApiResizeVMDiskRequest) ResizeVMDiskRequest(resizeVMDiskRequest ResizeVMDiskRequest) ApiResizeVMDiskRequest {
	r.resizeVMDiskRequest = &resizeVMDiskRequest
	return r
}

func (r ApiResizeVMDiskRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.ResizeVMDiskExecute(r)
}

/*
ResizeVMDisk resizeVMDisk

Extend volume size.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiResizeVMDiskRequest
*/
func (a *NodesAPIService) ResizeVMDisk(ctx context.Context, node string, vmid int64) ApiResizeVMDiskRequest {
	return ApiResizeVMDiskRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesAPIService) ResizeVMDiskExecute(r ApiResizeVMDiskRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.ResizeVMDisk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/resize"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resizeVMDiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeContainerRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	body *map[string]interface{}
}

func (r ApiResumeContainerRequest) Body(body map[string]interface{}) ApiResumeContainerRequest {
	r.body = &body
	return r
}

func (r ApiResumeContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.ResumeContainerExecute(r)
}

/*
ResumeContainer resumeContainer

Resume the container.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiResumeContainerRequest
*/
func (a *NodesAPIService) ResumeContainer(ctx context.Context, node string, vmid int64) ApiResumeContainerRequest {
	return ApiResumeContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) ResumeContainerExecute(r ApiResumeContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.ResumeContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/resume"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeVMRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	resumeVMRequest *ResumeVMRequest
}

func (r ApiResumeVMRequest) ResumeVMRequest(resumeVMRequest ResumeVMRequest) ApiResumeVMRequest {
	r.resumeVMRequest = &resumeVMRequest
	return r
}

func (r ApiResumeVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.ResumeVMExecute(r)
}

/*
ResumeVM resumeVM

Resume virtual machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiResumeVMRequest
*/
func (a *NodesAPIService) ResumeVM(ctx context.Context, node string, vmid int64) ApiResumeVMRequest {
	return ApiResumeVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) ResumeVMExecute(r ApiResumeVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.ResumeVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/resume"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resumeVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRollbackContainerSnapshotRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	snapname string
	rollbackContainerSnapshotRequest *RollbackContainerSnapshotRequest
}

func (r ApiRollbackContainerSnapshotRequest) RollbackContainerSnapshotRequest(rollbackContainerSnapshotRequest RollbackContainerSnapshotRequest) ApiRollbackContainerSnapshotRequest {
	r.rollbackContainerSnapshotRequest = &rollbackContainerSnapshotRequest
	return r
}

func (r ApiRollbackContainerSnapshotRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.RollbackContainerSnapshotExecute(r)
}

/*
RollbackContainerSnapshot rollbackContainerSnapshot

Rollback LXC state to specified snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @param snapname The name of the snapshot.
 @return ApiRollbackContainerSnapshotRequest
*/
func (a *NodesAPIService) RollbackContainerSnapshot(ctx context.Context, node string, vmid int64, snapname string) ApiRollbackContainerSnapshotRequest {
	return ApiRollbackContainerSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
		snapname: snapname,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesAPIService) RollbackContainerSnapshotExecute(r ApiRollbackContainerSnapshotRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.RollbackContainerSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot/{snapname}/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rollbackContainerSnapshotRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRollbackVMSnapshotRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	snapname string
	rollbackVMSnapshotRequest *RollbackVMSnapshotRequest
}

func (r ApiRollbackVMSnapshotRequest) RollbackVMSnapshotRequest(rollbackVMSnapshotRequest RollbackVMSnapshotRequest) ApiRollbackVMSnapshotRequest {
	r.rollbackVMSnapshotRequest = &rollbackVMSnapshotRequest
	return r
}

func (r ApiRollbackVMSnapshotRequest) Execute() (*TaskStartResponse, *http.Response, error) {
	return r.ApiService.RollbackVMSnapshotExecute(r)
}

/*
RollbackVMSnapshot rollbackVMSnapshot

Rollback VM state to specified snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @param snapname The name of the snapshot.
 @return ApiRollbackVMSnapshotRequest
*/
func (a *NodesAPIService) RollbackVMSnapshot(ctx context.Context, node string, vmid int64, snapname string) ApiRollbackVMSnapshotRequest {
	return ApiRollbackVMSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
		snapname: snapname,
	}
}

// Execute executes the request
//  @return TaskStartResponse
func (a *NodesAPIService) RollbackVMSnapshotExecute(r ApiRollbackVMSnapshotRequest) (*TaskStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.RollbackVMSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot/{snapname}/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rollbackVMSnapshotRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShutdownContainerRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	shutdownContainerRequest *ShutdownContainerRequest
}

func (r ApiShutdownContainerRequest) ShutdownContainerRequest(shutdownContainerRequest ShutdownContainerRequest) ApiShutdownContainerRequest {
	r.shutdownContainerRequest = &shutdownContainerRequest
	return r
}

func (r ApiShutdownContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.ShutdownContainerExecute(r)
}

/*
ShutdownContainer shutdownContainer

Shutdown the container. This will trigger a clean shutdown of the container, see lxc-stop(1) for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiShutdownContainerRequest
*/
func (a *NodesAPIService) ShutdownContainer(ctx context.Context, node string, vmid int64) ApiShutdownContainerRequest {
	return ApiShutdownContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) ShutdownContainerExecute(r ApiShutdownContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.ShutdownContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/shutdown"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.shutdownContainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShutdownVMRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	shutdownVMRequest *ShutdownVMRequest
}

func (r ApiShutdownVMRequest) ShutdownVMRequest(shutdownVMRequest ShutdownVMRequest) ApiShutdownVMRequest {
	r.shutdownVMRequest = &shutdownVMRequest
	return r
}

func (r ApiShutdownVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.ShutdownVMExecute(r)
}

/*
ShutdownVM shutdownVM

Shutdown virtual machine. This is similar to pressing the power button on a physical machine.This will send an ACPI event for the guest OS, which should then proceed to a clean shutdown.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiShutdownVMRequest
*/
func (a *NodesAPIService) ShutdownVM(ctx context.Context, node string, vmid int64) ApiShutdownVMRequest {
	return ApiShutdownVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) ShutdownVMExecute(r ApiShutdownVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.ShutdownVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/shutdown"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.shutdownVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartContainerRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	startContainerRequest *StartContainerRequest
}

func (r ApiStartContainerRequest) StartContainerRequest(startContainerRequest StartContainerRequest) ApiStartContainerRequest {
	r.startContainerRequest = &startContainerRequest
	return r
}

func (r ApiStartContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.StartContainerExecute(r)
}

/*
StartContainer startContainer

Start the container.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiStartContainerRequest
*/
func (a *NodesAPIService) StartContainer(ctx context.Context, node string, vmid int64) ApiStartContainerRequest {
	return ApiStartContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) StartContainerExecute(r ApiStartContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.StartContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/start"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startContainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartVMRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	startVMRequest *StartVMRequest
}

func (r ApiStartVMRequest) StartVMRequest(startVMRequest StartVMRequest) ApiStartVMRequest {
	r.startVMRequest = &startVMRequest
	return r
}

func (r ApiStartVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.StartVMExecute(r)
}

/*
StartVM startVM

Start virtual machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiStartVMRequest
*/
func (a *NodesAPIService) StartVM(ctx context.Context, node string, vmid int64) ApiStartVMRequest {
	return ApiStartVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) StartVMExecute(r ApiStartVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.StartVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/start"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopContainerRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	stopContainerRequest *StopContainerRequest
}

func (r ApiStopContainerRequest) StopContainerRequest(stopContainerRequest StopContainerRequest) ApiStopContainerRequest {
	r.stopContainerRequest = &stopContainerRequest
	return r
}

func (r ApiStopContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.StopContainerExecute(r)
}

/*
StopContainer stopContainer

Stop the container. This will abruptly stop all processes running in the container.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiStopContainerRequest
*/
func (a *NodesAPIService) StopContainer(ctx context.Context, node string, vmid int64) ApiStopContainerRequest {
	return ApiStopContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) StopContainerExecute(r ApiStopContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.StopContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stopContainerRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopNodeTaskRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	upid string
}

func (r ApiStopNodeTaskRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.StopNodeTaskExecute(r)
}

/*
StopNodeTask stopNodeTask

Stop a task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param upid
 @return ApiStopNodeTaskRequest
*/
func (a *NodesAPIService) StopNodeTask(ctx context.Context, node string, upid string) ApiStopNodeTaskRequest {
	return ApiStopNodeTaskRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		upid: upid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) StopNodeTaskExecute(r ApiStopNodeTaskRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.StopNodeTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/tasks/{upid}"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upid"+"}", url.PathEscape(parameterValueToString(r.upid, "upid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopVMRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	stopVMRequest *StopVMRequest
}

func (r ApiStopVMRequest) StopVMRequest(stopVMRequest StopVMRequest) ApiStopVMRequest {
	r.stopVMRequest = &stopVMRequest
	return r
}

func (r ApiStopVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.StopVMExecute(r)
}

/*
StopVM stopVM

Stop virtual machine. The qemu process will exit immediately. Thisis akin to pulling the power plug of a running computer and may damage the VM data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiStopVMRequest
*/
func (a *NodesAPIService) StopVM(ctx context.Context, node string, vmid int64) ApiStopVMRequest {
	return ApiStopVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) StopVMExecute(r ApiStopVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.StopVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stopVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuspendContainerRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	body *map[string]interface{}
}

func (r ApiSuspendContainerRequest) Body(body map[string]interface{}) ApiSuspendContainerRequest {
	r.body = &body
	return r
}

func (r ApiSuspendContainerRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.SuspendContainerExecute(r)
}

/*
SuspendContainer suspendContainer

Suspend the container. This is experimental.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiSuspendContainerRequest
*/
func (a *NodesAPIService) SuspendContainer(ctx context.Context, node string, vmid int64) ApiSuspendContainerRequest {
	return ApiSuspendContainerRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) SuspendContainerExecute(r ApiSuspendContainerRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.SuspendContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/status/suspend"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuspendVMRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	suspendVMRequest *SuspendVMRequest
}

func (r ApiSuspendVMRequest) SuspendVMRequest(suspendVMRequest SuspendVMRequest) ApiSuspendVMRequest {
	r.suspendVMRequest = &suspendVMRequest
	return r
}

func (r ApiSuspendVMRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.SuspendVMExecute(r)
}

/*
SuspendVM suspendVM

Suspend virtual machine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiSuspendVMRequest
*/
func (a *NodesAPIService) SuspendVM(ctx context.Context, node string, vmid int64) ApiSuspendVMRequest {
	return ApiSuspendVMRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) SuspendVMExecute(r ApiSuspendVMRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.SuspendVM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/status/suspend"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.suspendVMRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateContainerConfigSyncRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	updateContainerConfigSyncRequest *UpdateContainerConfigSyncRequest
}

func (r ApiUpdateContainerConfigSyncRequest) UpdateContainerConfigSyncRequest(updateContainerConfigSyncRequest UpdateContainerConfigSyncRequest) ApiUpdateContainerConfigSyncRequest {
	r.updateContainerConfigSyncRequest = &updateContainerConfigSyncRequest
	return r
}

func (r ApiUpdateContainerConfigSyncRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.UpdateContainerConfigSyncExecute(r)
}

/*
UpdateContainerConfigSync updateContainerConfigSync

Set container options.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiUpdateContainerConfigSyncRequest
*/
func (a *NodesAPIService) UpdateContainerConfigSync(ctx context.Context, node string, vmid int64) ApiUpdateContainerConfigSyncRequest {
	return ApiUpdateContainerConfigSyncRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) UpdateContainerConfigSyncExecute(r ApiUpdateContainerConfigSyncRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.UpdateContainerConfigSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateContainerConfigSyncRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateContainerSnapshotConfigRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	snapname string
	updateContainerSnapshotConfigRequest *UpdateContainerSnapshotConfigRequest
}

func (r ApiUpdateContainerSnapshotConfigRequest) UpdateContainerSnapshotConfigRequest(updateContainerSnapshotConfigRequest UpdateContainerSnapshotConfigRequest) ApiUpdateContainerSnapshotConfigRequest {
	r.updateContainerSnapshotConfigRequest = &updateContainerSnapshotConfigRequest
	return r
}

func (r ApiUpdateContainerSnapshotConfigRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.UpdateContainerSnapshotConfigExecute(r)
}

/*
UpdateContainerSnapshotConfig updateContainerSnapshotConfig

Update snapshot metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @param snapname The name of the snapshot.
 @return ApiUpdateContainerSnapshotConfigRequest
*/
func (a *NodesAPIService) UpdateContainerSnapshotConfig(ctx context.Context, node string, vmid int64, snapname string) ApiUpdateContainerSnapshotConfigRequest {
	return ApiUpdateContainerSnapshotConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
		snapname: snapname,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) UpdateContainerSnapshotConfigExecute(r ApiUpdateContainerSnapshotConfigRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.UpdateContainerSnapshotConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/lxc/{vmid}/snapshot/{snapname}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateContainerSnapshotConfigRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVMConfigRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	updateVMConfigRequest *UpdateVMConfigRequest
}

func (r ApiUpdateVMConfigRequest) UpdateVMConfigRequest(updateVMConfigRequest UpdateVMConfigRequest) ApiUpdateVMConfigRequest {
	r.updateVMConfigRequest = &updateVMConfigRequest
	return r
}

func (r ApiUpdateVMConfigRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.UpdateVMConfigExecute(r)
}

/*
UpdateVMConfig updateVMConfig

Set virtual machine options (asynchrounous API).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiUpdateVMConfigRequest
*/
func (a *NodesAPIService) UpdateVMConfig(ctx context.Context, node string, vmid int64) ApiUpdateVMConfigRequest {
	return ApiUpdateVMConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) UpdateVMConfigExecute(r ApiUpdateVMConfigRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.UpdateVMConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateVMConfigRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVMConfigSyncRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	updateVMConfigSyncRequest *UpdateVMConfigSyncRequest
}

func (r ApiUpdateVMConfigSyncRequest) UpdateVMConfigSyncRequest(updateVMConfigSyncRequest UpdateVMConfigSyncRequest) ApiUpdateVMConfigSyncRequest {
	r.updateVMConfigSyncRequest = &updateVMConfigSyncRequest
	return r
}

func (r ApiUpdateVMConfigSyncRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.UpdateVMConfigSyncExecute(r)
}

/*
UpdateVMConfigSync updateVMConfigSync

Set virtual machine options (synchrounous API) - You should consider using the POST method instead for any actions involving hotplug or storage allocation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @return ApiUpdateVMConfigSyncRequest
*/
func (a *NodesAPIService) UpdateVMConfigSync(ctx context.Context, node string, vmid int64) ApiUpdateVMConfigSyncRequest {
	return ApiUpdateVMConfigSyncRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) UpdateVMConfigSyncExecute(r ApiUpdateVMConfigSyncRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.UpdateVMConfigSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateVMConfigSyncRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVMSnapshotConfigRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	vmid int64
	snapname string
	updateVMSnapshotConfigRequest *UpdateVMSnapshotConfigRequest
}

func (r ApiUpdateVMSnapshotConfigRequest) UpdateVMSnapshotConfigRequest(updateVMSnapshotConfigRequest UpdateVMSnapshotConfigRequest) ApiUpdateVMSnapshotConfigRequest {
	r.updateVMSnapshotConfigRequest = &updateVMSnapshotConfigRequest
	return r
}

func (r ApiUpdateVMSnapshotConfigRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.UpdateVMSnapshotConfigExecute(r)
}

/*
UpdateVMSnapshotConfig updateVMSnapshotConfig

Update snapshot metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param vmid The (unique) ID of the VM.
 @param snapname The name of the snapshot.
 @return ApiUpdateVMSnapshotConfigRequest
*/
func (a *NodesAPIService) UpdateVMSnapshotConfig(ctx context.Context, node string, vmid int64, snapname string) ApiUpdateVMSnapshotConfigRequest {
	return ApiUpdateVMSnapshotConfigRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		vmid: vmid,
		snapname: snapname,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) UpdateVMSnapshotConfigExecute(r ApiUpdateVMSnapshotConfigRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.UpdateVMSnapshotConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/qemu/{vmid}/snapshot/{snapname}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterValueToString(r.vmid, "vmid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapname"+"}", url.PathEscape(parameterValueToString(r.snapname, "snapname")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vmid < 100 {
		return localVarReturnValue, nil, reportError("vmid must be greater than 100")
	}
	if r.vmid > 999999999 {
		return localVarReturnValue, nil, reportError("vmid must be less than 999999999")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateVMSnapshotConfigRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadFileRequest struct {
	ctx context.Context
	ApiService NodesAPI
	node string
	storage string
	content *string
	filename *os.File
	checksum *string
	checksumAlgorithm *string
	tmpfilename *string
}

// Content type.
func (r ApiUploadFileRequest) Content(content string) ApiUploadFileRequest {
	r.content = &content
	return r
}

// The name of the file to create. Caution: This will be normalized!
func (r ApiUploadFileRequest) Filename(filename *os.File) ApiUploadFileRequest {
	r.filename = filename
	return r
}

// The expected checksum of the file.
func (r ApiUploadFileRequest) Checksum(checksum string) ApiUploadFileRequest {
	r.checksum = &checksum
	return r
}

// The algorithm to calculate the checksum of the file.
func (r ApiUploadFileRequest) ChecksumAlgorithm(checksumAlgorithm string) ApiUploadFileRequest {
	r.checksumAlgorithm = &checksumAlgorithm
	return r
}

// The source file name. This parameter is usually set by the REST handler. You can only overwrite it when connecting to the trusted port on localhost.
func (r ApiUploadFileRequest) Tmpfilename(tmpfilename string) ApiUploadFileRequest {
	r.tmpfilename = &tmpfilename
	return r
}

func (r ApiUploadFileRequest) Execute() (*CreateVM200Response, *http.Response, error) {
	return r.ApiService.UploadFileExecute(r)
}

/*
UploadFile uploadFile

Upload templates and ISO images.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param node The cluster node name.
 @param storage The storage identifier.
 @return ApiUploadFileRequest
*/
func (a *NodesAPIService) UploadFile(ctx context.Context, node string, storage string) ApiUploadFileRequest {
	return ApiUploadFileRequest{
		ApiService: a,
		ctx: ctx,
		node: node,
		storage: storage,
	}
}

// Execute executes the request
//  @return CreateVM200Response
func (a *NodesAPIService) UploadFileExecute(r ApiUploadFileRequest) (*CreateVM200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVM200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodesAPIService.UploadFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{node}/storage/{storage}/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storage"+"}", url.PathEscape(parameterValueToString(r.storage, "storage")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}
	if r.filename == nil {
		return localVarReturnValue, nil, reportError("filename is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.checksum != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "checksum", r.checksum, "")
	}
	if r.checksumAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "checksum-algorithm", r.checksumAlgorithm, "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "content", r.content, "")
	var filenameLocalVarFormFileName string
	var filenameLocalVarFileName     string
	var filenameLocalVarFileBytes    []byte

	filenameLocalVarFormFileName = "filename"
	filenameLocalVarFile := r.filename

	if filenameLocalVarFile != nil {
		fbs, _ := io.ReadAll(filenameLocalVarFile)

		filenameLocalVarFileBytes = fbs
		filenameLocalVarFileName = filenameLocalVarFile.Name()
		filenameLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: filenameLocalVarFileBytes, fileName: filenameLocalVarFileName, formFileName: filenameLocalVarFormFileName})
	}
	if r.tmpfilename != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tmpfilename", r.tmpfilename, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["CSRFPreventionToken"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
